<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试基础</title>
      <link href="/KendricW.github.io/2024/03/21/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/KendricW.github.io/2024/03/21/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试基础"><a href="#Java面试基础" class="headerlink" title="Java面试基础"></a>Java面试基础</h1><h2 id="Java语言的三大特性"><a href="#Java语言的三大特性" class="headerlink" title="Java语言的三大特性"></a>Java语言的三大特性</h2><ul><li><p>封装</p><ul><li>把属于同一类事物的共性（属性和方法）归到一个类中，以方便实用</li><li>专业分工，需要的时候再调用</li><li>隐藏信息，实现细节</li></ul></li><li><p>继承</p><ul><li>实现代码复用</li><li>遵行李氏代替原则</li><li>父类私有的属性和构造方法不能被继承</li><li>子类可以写自己特有的属性和方法，目的是实现功能的扩展</li></ul></li><li><p>多态</p><ul><li>以封装和继承为基础的</li><li>相同的事物，调用相同的方法，参数相同，但是表现的行为却不同</li><li>子类以父类的身份出现需要向上转型(upcast),其中向上转型是JVM自动实现的，是安全的</li><li>向下转型不安全，需要强制转换</li><li>子类以父类的身份出现时自己特有的属性和方法都不能使用</li></ul></li></ul><h2 id="JDK和JRE有什么区别？"><a href="#JDK和JRE有什么区别？" class="headerlink" title="JDK和JRE有什么区别？"></a>JDK和JRE有什么区别？</h2><ul><li>JDK：Java Development Kit的简称，Java开发工具包，提供开发环境和运行环境</li><li>JRE：Java Runtime Environment的简称，Java运行环境</li></ul><p>JDK包含JRE，还包括javac，调试和分析的工具</p><h2 id="如果main方法被声明为private会怎样？"><a href="#如果main方法被声明为private会怎样？" class="headerlink" title="如果main方法被声明为private会怎样？"></a>如果main方法被声明为private会怎样？</h2><ul><li>能正常编译，但是会提示不是public的</li><li>idea中会去掉可运行的按钮</li></ul><h2 id="与equals"><a href="#与equals" class="headerlink" title="&#x3D;&#x3D;与equals"></a>&#x3D;&#x3D;与equals</h2><ul><li>&#x3D;&#x3D;比较的是两个对象在内存中是不是同一个对象，就是说在内存里的存储位置一样</li><li>&#x3D;&#x3D;比较的是引用</li><li>equal比较的是内容</li></ul><h2 id="Object有哪些共用的方法"><a href="#Object有哪些共用的方法" class="headerlink" title="Object有哪些共用的方法"></a>Object有哪些共用的方法</h2><ul><li>clone 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用</li><li>equals 和&#x3D;&#x3D;一样，子类一般需要重写该方法</li><li>hashCode 哈希查找，重写了euqals方法一班都徐亚重写hashCode方法，在一些具有哈希功能的Collection中用到</li><li>getClass final方法，获得运行是类型</li><li>wait 使当前线程等待对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁，该方法一直等待，知道获得或者被中断，wait(long timeout)设定一个超时间隔，没有在规定时间内获得锁就返回</li><li>调用方法后当前线程进入睡眠状态<ul><li>其他线程调用了该对象的notify方法</li><li>其他线程调用了该对象的notifyAll方法</li><li>其他线程调用了interrupt中断该线程</li><li>时间间隔到了</li><li>线程可被调度，中断的话就抛异常</li></ul></li><li>notify 唤醒在该对象等待的某个线程</li><li>notifyAll 唤醒在该对象等待的所有线程</li><li>toString 一般子类重写</li></ul><h2 id="为什么Java中没有全局变量？"><a href="#为什么Java中没有全局变量？" class="headerlink" title="为什么Java中没有全局变量？"></a>为什么Java中没有全局变量？</h2><p>因为全局变量破坏了引用透明性原则，全局变量导致了命名空间的冲突</p><h2 id="while和dowhile有什么不同"><a href="#while和dowhile有什么不同" class="headerlink" title="while和dowhile有什么不同"></a>while和dowhile有什么不同</h2><p>dowhile至少执行一次</p><h2 id="char类型变量中能不能存储一个中文汉字？为什么？"><a href="#char类型变量中能不能存储一个中文汉字？为什么？" class="headerlink" title="char类型变量中能不能存储一个中文汉字？为什么？"></a>char类型变量中能不能存储一个中文汉字？为什么？</h2><p>可以</p><p>Java默认Unicode编码，占16位，char刚好就是16位</p><h2 id="float-f-3-4-是否正确-？"><a href="#float-f-3-4-是否正确-？" class="headerlink" title="float f &#x3D; 3.4;是否正确 ？"></a>float f &#x3D; 3.4;是否正确 ？</h2><p>不正确</p><p>3.4是双精度数double，向下转型会照成精度损失</p><p>正确写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">3.4</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.4F</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试，基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/KendricW.github.io/2024/03/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/KendricW.github.io/2024/03/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的生命周期</title>
      <link href="/KendricW.github.io/2024/03/20/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/KendricW.github.io/2024/03/20/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的声明周期描述了一个类“加载，使用，卸载”的整个过程，整体可以分为：</p><ul><li>加载</li><li>连接 （验证，准备，解析）三个子阶段</li><li>初始化</li><li>使用</li><li>卸载</li></ul><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>类加载器根据类的全限定名通过不同渠道以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。</p><ul><li>本地硬盘获取文件</li><li>运行时通过动态代理生成，例如Spring框架</li><li>Applet技术通过网络取字节码文件</li></ul><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>加载完类以后， Java虚拟机会将字节码中的信息保存在方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里面还包括实现特定功能比如多态的信息。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据（ jdk8及之后）</p><h2 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h2><p>三个子阶段：</p><ul><li>验证 验证内容是否满足《Java虚拟机规范》</li><li>准备 给静态变量赋初值</li><li>解析 将常量池中的符号引用替换成指向内存的直接引用</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要目的：检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段不需要程序员参与</p><p>主要包含下面四部分：</p><ul><li>文件格式验证，ca fe魔数的校验，主次版本号</li><li>元信息验证，例如类必须有父类（super不能为空）</li><li>验证城西执行指令的语意，比如方法内的指令执行中跳转到不正确的位置</li><li>符号引用验证，例如是否访问了其他类中private的方法等</li></ul><p>主版本号的验证：</p><p>编译文件的主版本号不能高于运行环境主版本号</p><p>如果主版本号相等，副版本号也不能超过。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>初始值</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td><strong>0</strong></td></tr><tr><td><strong>long</strong></td><td><strong>0L</strong></td></tr><tr><td><strong>short</strong></td><td><strong>0</strong></td></tr><tr><td><strong>char</strong></td><td><strong>‘\u0000’</strong></td></tr><tr><td><strong>byte</strong></td><td><strong>0</strong></td></tr><tr><td><strong>boolean</strong></td><td><strong>false</strong></td></tr><tr><td><strong>double</strong></td><td><strong>0.0</strong></td></tr><tr><td><strong>引用****数据类型</strong></td><td><strong>null</strong></td></tr></tbody></table><p>如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在准备阶段会为value分配内存并赋初值为0，在初始化阶段才会将值修改为1。</p><p>final修饰的变量，在准备阶段直接赋值。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段主要是将常量池中的符号引用替换为直接引用</p><p>符号引用就是在字节码文件中使用编号来访问常量池的内容</p><p>直接引用不再使用编号，而是使用内存中地址进行访问具体的数据</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>初始化阶段会执行字节码文件中的clinit（class init类的初始化）方法的字节码指令，包含了静态代码快中的代码，并为静态变量赋值</p><p>如下代码编译成字节码文件之后，会生成三个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[0]  init</p><p>[1] main</p><p>[2]  clinit</p><ul><li>init方法，会在对象初始化时执行</li><li>main方法，主方法</li><li>clinit方法，类的初始化阶段执行</li></ul><h2 id="导致类的初始化："><a href="#导致类的初始化：" class="headerlink" title="导致类的初始化："></a>导致类的初始化：</h2><p>1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。</p><p>2.调用Class.forName(String className)。</p><p>3.new一个该类的对象时。</p><p>4.执行Main方法的当前类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果应该是DACBCB</p><h4 id="clinit不会执行的几种情况"><a href="#clinit不会执行的几种情况" class="headerlink" title="clinit不会执行的几种情况"></a>clinit不会执行的几种情况</h4><p>如下几种情况是不会进行初始化指令执行的：</p><p>1.无静态代码块且无静态变量赋值语句。</p><p>2.有静态变量的声明，但是没有赋值语句。</p><p>3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如下代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B02</span>();</span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_">A02</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析步骤：</p><p>1、调用new创建对象，需要初始化B02，优先初始化父类。</p><p>2、执行A02的初始化代码，将a赋值为1。</p><p>3、B02初始化，将a赋值为2。</p><h5 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h5><p>将<code>new B02();</code>注释掉会怎么样？</p><p>分析步骤：</p><p>1、访问父类的静态变量，只初始化父类。</p><p>2、执行A02的初始化代码，将a赋值为1。</p><h4 id="补充练习题"><a href="#补充练习题" class="headerlink" title="补充练习题"></a>补充练习题</h4><p>分析如下代码执行结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test2_A[] arr = <span class="keyword">new</span> <span class="title class_">Test2_A</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2_A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test2 A的静态代码块运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的创建不会导致数组中元素的类进行初始化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test4_A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test4_A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test3 A的静态代码块运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码文件</title>
      <link href="/KendricW.github.io/2024/03/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"/>
      <url>/KendricW.github.io/2024/03/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码文件详解"><a href="#字节码文件详解" class="headerlink" title="字节码文件详解"></a>字节码文件详解</h1><h2 id="Java虚拟机的组成"><a href="#Java虚拟机的组成" class="headerlink" title="Java虚拟机的组成"></a>Java虚拟机的组成</h2><p>Java虚拟机主要分为以下几个组成部分：</p><ul><li>类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。</li><li>运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。</li><li>执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。</li><li>本地接口：调用本地使用C&#x2F;C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示。</li></ul><h2 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h2><h3 id="以正确的姿势打开文件"><a href="#以正确的姿势打开文件" class="headerlink" title="以正确的姿势打开文件"></a>以正确的姿势打开文件</h3><p>无法解读出文件里包含的内容，推荐使用 jclasslib工具查看字节码文件。</p><p>Github地址： <a href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a></p><h3 id="字节码文件的组成-1"><a href="#字节码文件的组成-1" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><p>字节码文件总共可以分为以下几个部分：</p><ul><li><strong>基础信息</strong>：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息</li><li><strong>常量池</strong>： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段：</strong> 当前类或接口声明的字段信息</li><li><strong>方法：</strong> 当前类或接口声明的方法信息，核心内容为方法的字节码指令</li><li><strong>属性：</strong> 类的属性，比如源码的文件名、内部类的列表等</li></ul><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p><strong>Magic魔数</strong></p><p>每个Java字节码文件的前四个字节是固定的，用16进制表示就是0xcafebabe。文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。</p><p>Java字节码文件中，将文件头称为magic魔数。Java虚拟机会校验字节码文件的前四个字节是不是0xcafebabe，如果不是，该字节码文件就无法正常使用，Java虚拟机会抛出对应的错误。</p><p><strong>主副版本号</strong></p><p>1.2之后大版本号计算方法就是 : <em><strong>主版本号 – 44，比如主版本号52就是JDK8。</strong></em></p><p>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。如果使用较低版本的JDK去运行较高版本JDK的字节码文件，无法使用会显示错误</p><p>有两种方案：</p><p>1.<strong>升级JDK版本</strong>，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。</p><p>2.<strong>将第三方依赖的版本号降低或者更换依赖</strong>，以满足JDK版本的要求。建议使用这种方案</p><p><strong>其他基础信息</strong></p><p>其他基础信息包括访问标识、类和接口索引</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。</p><p>比如在代码中，编写了两个相同的字符串“我爱北京天安门”，字节码文件甚至将来在内存中使用时其实只需要保存一份，此时就可以将这个字符串以及字符串里边包含的字面量，放入常量池中以达到节省空间的作用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;我爱北京天安门&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;我爱北京天安门&quot;</span>;</span><br></pre></td></tr></table></figure><p>常量池中的数据都有一个编号，编号从1开始。比如“我爱北京天安门”这个字符串，在常量池中的编号就是7。在字段或者字节码指令中通过编号7可以快速的找到这个字符串。</p><p>字节码指令中通过编号引用到常量池的过程称之为符号引用。</p><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>字段中存放的是当前类或接口声明的字段信息。</p><p>如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public&#x2F;private static final等）。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>字节码中的方法区域是存放<strong>字节码****指令</strong>的核心位置，字节码指令的内容存放在方法的Code属性中。</p><p>要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。</p><p><strong>操作数栈</strong>是用来存放临时数据的内容，是一个栈式的结构，先进后出。</p><p><strong>局部变量****表</strong>是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JVM</title>
      <link href="/KendricW.github.io/2024/03/19/%E5%88%9D%E8%AF%86JVM/"/>
      <url>/KendricW.github.io/2024/03/19/%E5%88%9D%E8%AF%86JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="初识JVM-基础"><a href="#初识JVM-基础" class="headerlink" title="初识JVM-基础"></a>初识JVM-基础</h1><p><code>JVM</code>全称：JAVA Virtual Machine，中文名Java虚拟机，是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p><h2 id="Java源代码执行流程如下："><a href="#Java源代码执行流程如下：" class="headerlink" title="Java源代码执行流程如下："></a>Java源代码执行流程如下：</h2><p>分为三个步骤：<br>1.编写Java源代码文件。<br>2.使用Java编译器（javac命令）将源代码编译成Java字节码文件。<br>3.使用Java虚拟机加载并运行Java字节码文件，此时会启动一个新的进程。</p><h2 id="Java的三大核心功能"><a href="#Java的三大核心功能" class="headerlink" title="Java的三大核心功能"></a>Java的三大核心功能</h2><ul><li>内存管理</li><li>解释执行虚拟机指令</li><li>及时编译</li></ul><h3 id="解释和运行"><a href="#解释和运行" class="headerlink" title="解释和运行"></a>解释和运行</h3><p>对字节码文件中的指令，实时的解释成机器码，让计算机执行。</p><p>字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>自动为对象、方法等分配内存</li><li>自动的垃圾回收机制，回收不再使用的对象</li></ul><p>Java虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C&#x2F;C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。</p><h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><p>热点代码进行优化，提升执行效率。</p><p><strong>提升Java最核心的手段</strong></p><h2 id="Java性能低的主要原因和跨平台特性"><a href="#Java性能低的主要原因和跨平台特性" class="headerlink" title="Java性能低的主要原因和跨平台特性"></a>Java性能低的主要原因和跨平台特性</h2><p>Java语言如果不做任何的优化，性能其实是不如C和C++语言的。主要原因是：</p><p>在程序运行过程中，Java虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。</p><p>C和C++语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。</p><p>Java为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在windows或者linux上运行。可以使用同一份字节码指令，交给windows和linux上的Java虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了Write Once，Run Anywhere 编写一次，到处运行的目标。</p><p>但是C&#x2F;C++语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。</p><p>再回到即时编译，在JDK1.1的版本中就推出了即时编译去优化对应的性能。</p><p>虚拟机在运行过程中如果发现某一个方法甚至是循环是热点代码（被非常高频调用），即时编译器会优化这段代码并将优化后的机器码保存在内存中，如果第二次再去执行这段代码。Java虚拟机会将机器码从内存中取出来直接进行调用。这样节省了一次解释的步骤，同时执行的是优化后的代码，效率较高。</p><p>Java通过即时编译器获得了接近C&#x2F;C++语言的性能，在某些特定的场景下甚至可以实现超越。</p><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><table><thead><tr><th>名称</th><th>作者</th><th>支持版本</th><th>社区活跃度（github star）</th><th>特性</th><th>适用场景</th></tr></thead><tbody><tr><td>HotSpot (Oracle JDK版)</td><td>Oracle</td><td>所有版本</td><td>高(闭源)</td><td>使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机</td><td>默认</td></tr><tr><td>HotSpot (Open JDK版)</td><td>Oracle</td><td>所有版本</td><td>中(16.1k)</td><td>同上开源，Open JDK默认虚拟机</td><td>默认对JDK有二次开发需求</td></tr><tr><td>GraalVM</td><td>Oracle</td><td>11, 17,19企业版支持8</td><td>高（18.7k）</td><td>多语言支持高性能、JIT、AOT支持</td><td>微服务、云原生架构需要多语言混合编程</td></tr><tr><td>Dragonwell JDK龙井</td><td>Alibaba</td><td>标准版 8,11,17扩展版11,17</td><td>低(3.9k)</td><td>基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持</td><td>电商、物流、金融领域对性能要求比较高</td></tr><tr><td>Eclipse OpenJ9 (原 IBM J9)</td><td>IBM</td><td>8,11,17,19,20</td><td>低(3.1k)</td><td>高性能、可扩展JIT、AOT特性支持</td><td>微服务、云原生架构</td></tr></tbody></table><h2 id="HotSpot的发展历程"><a href="#HotSpot的发展历程" class="headerlink" title="HotSpot的发展历程"></a>HotSpot的发展历程</h2><h5 id="初出茅庐-1999年4月"><a href="#初出茅庐-1999年4月" class="headerlink" title="初出茅庐 - 1999年4月"></a>初出茅庐 - 1999年4月</h5><p>源自1997年收购的SmallTalk语言的虚拟机，HotSpot虚拟机初次在JDK中使用。在JDK1.2中作为附加功能存在，</p><p>JDK1.3之后作为默认的虚拟机。</p><h5 id="野蛮生长-2006年12月"><a href="#野蛮生长-2006年12月" class="headerlink" title="野蛮生长 - 2006年12月"></a>野蛮生长 - 2006年12月</h5><p>JDK 6发布，并在虚拟机层面做了大量的优化，这些优化对后续虚拟机的发展产生了深远的影响。</p><h5 id="稳步前进-2009-2013"><a href="#稳步前进-2009-2013" class="headerlink" title="稳步前进 - 2009-2013"></a>稳步前进 - 2009-2013</h5><p>JDK7中首次推出了G1垃圾收集器。收购了Sun公司之后，吸纳了JRockIt虚拟机的一些设计思想，JDK8中引入了JMC等工具，去除了永久代。</p><h5 id="百家争鸣-2018-2019"><a href="#百家争鸣-2018-2019" class="headerlink" title="百家争鸣 - 2018-2019"></a>百家争鸣 - 2018-2019</h5><p>JDK11优化了G1垃圾收集器的性能,同时推出了ZGC新一代的垃圾回收器，JDK12推出Shenan-doah垃圾回收器。</p><h5 id="拥抱云原生-2019-至今"><a href="#拥抱云原生-2019-至今" class="headerlink" title="拥抱云原生 - 2019-至今"></a>拥抱云原生 - 2019-至今</h5><p>以Hotspot为基础的GraalVM虚拟机诞生，不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构。</p><h2 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h2><ul><li>类加载器ClassLoader 加载class字节码文件中的内容到内存中</li><li>运行时数据区域（jvm管理的内存）负责管理jvm使用到的内存，创建对象你和销毁对象</li><li>执行引擎（即时编译器，解释器，垃圾回收器等） 将字节码文件中的指令解释称机械码，同时使用即时编译器优化性能</li><li>本地接口 调用本地已经变异的方法，比如虚拟机中提供的c&#x2F;c++的方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> sleep（）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger</title>
      <link href="/KendricW.github.io/2024/03/17/swagger/"/>
      <url>/KendricW.github.io/2024/03/17/swagger/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li><p>使得前后端分离开发更加方便，有利于团队协作</p></li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试 </p><p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p></li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><h3 id="导入-knife4j-的maven坐标"><a href="#导入-knife4j-的maven坐标" class="headerlink" title="导入 knife4j 的maven坐标"></a>导入 knife4j 的maven坐标</h3><p>在pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3 id="在配置类中加入-knife4j-相关配置"><a href="#在配置类中加入-knife4j-相关配置" class="headerlink" title="在配置类中加入 knife4j 相关配置"></a>在配置类中加入 knife4j 相关配置</h3><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过knife4j生成接口文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="设置静态资源映射，否则接口文档页面无法访问"><a href="#设置静态资源映射，否则接口文档页面无法访问" class="headerlink" title="设置静态资源映射，否则接口文档页面无法访问"></a>设置静态资源映射，否则接口文档页面无法访问</h3><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>接口文档访问路径为 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a> —&gt; <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p></li></ol><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口测试 </tag>
            
            <tag> kni4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签到及连续签到统计</title>
      <link href="/KendricW.github.io/2024/03/16/%E7%AD%BE%E5%88%B0%E5%8F%8A%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1/"/>
      <url>/KendricW.github.io/2024/03/16/%E7%AD%BE%E5%88%B0%E5%8F%8A%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><h4 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成</p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><em><strong>BitMap的操作命令有：</strong></em></p><ul><li><em><strong>SETBIT：向指定位置（offset）存入一个0或1</strong></em></li><li><em><strong>GETBIT ：获取指定位置（offset）的bit值</strong></em></li><li><em><strong>BITCOUNT ：统计BitMap中值为1的bit位的数量</strong></em></li><li><em><strong>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</strong></em></li><li><em><strong>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</strong></em></li><li><em><strong>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</strong></em></li><li><em><strong>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</strong></em></li><li></li></ul><h4 id="用户签到-实现签到功能"><a href="#用户签到-实现签到功能" class="headerlink" title="用户签到-实现签到功能"></a>用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 签到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量删除</title>
      <link href="/KendricW.github.io/2024/03/16/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4xmlsql/"/>
      <url>/KendricW.github.io/2024/03/16/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4xmlsql/</url>
      
        <content type="html"><![CDATA[<h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealDishMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据菜品id查询对应的套餐id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dishIds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)</span></span><br><span class="line">    List&lt;Long&gt; <span class="title function_">getSetmealIdsByDishIds</span><span class="params">(List&lt;Long&gt; dishIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sky.mapper.SetmealDishMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSetmealIdsByDishIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">        select setmeal_id from setmeal_dish where dish_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;dishIds&quot;</span> <span class="attr">item</span>=<span class="string">&quot;dishId&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;dishId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>collection</code>: Mapper层传入的集合参数</p><p><code>item</code>: 当前遍历集合的元素</p><p><code>separator</code>: 每个元素之间的分隔符</p><p><code>open=&quot;(&quot;</code> : 左侧拼接(</p><p><code>close=&quot;)&quot;</code>: 右侧拼接)</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批量删除 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/KendricW.github.io/2024/03/16/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/KendricW.github.io/2024/03/16/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p>省略解压的部分<br>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>默认的安装路径是在 <code>/usr/local/bin</code>目录<br>如果没有出错，应该就安装成功了。<br>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台</p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>进入到sky-server模块</p><p><strong>1). 导入Spring Data Redis的maven坐标(已完成)</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置Redis数据源</strong></p><p>在application-dev.yml中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p><p>在application.yml中添加读取application-dev.yml中的相关Redis配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;sky.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;sky.redis.port&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;sky.redis.password&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;sky.redis.database&#125;</span></span><br></pre></td></tr></table></figure><p><strong>3). 编写配置类，创建RedisTemplate对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板对象...&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        <span class="comment">//设置redis的连接工厂对象</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//设置redis key的序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为</p><p>JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为</p><p>StringRedisSerializer序列化器。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>登录与校验的思路</title>
      <link href="/KendricW.github.io/2024/03/13/%E7%99%BB%E5%BD%95%E4%B8%8E%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/KendricW.github.io/2024/03/13/%E7%99%BB%E5%BD%95%E4%B8%8E%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="登录校验思路"><a href="#登录校验思路" class="headerlink" title="登录校验思路"></a>登录校验思路</h1><p><code>DTO</code>：DTO是一种设计模式，它主要用来封装需要在网络间传输的数据或者在应用程序的不同层级间进行传递的对象。DTO通常包含了服务层操作所需的全部或部分数据</p><p><code>VO</code>：用于封装用户界面展示所需的数据，以及接收用户输入的数据。</p><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;员工登录&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">            jwtProperties.getAdminSecretKey(),</span><br><span class="line">            jwtProperties.getAdminTtl(),</span><br><span class="line">            claims);</span><br><span class="line"></span><br><span class="line">    <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">            .id(employee.getId())</span><br><span class="line">            .userName(employee.getUsername())</span><br><span class="line">            .name(employee.getName())</span><br><span class="line">            .token(token)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JwtUtil工具类"><a href="#JwtUtil工具类" class="headerlink" title="JwtUtil工具类"></a>JwtUtil工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt</span></span><br><span class="line"><span class="comment">     * 使用Hs256算法, 私匙使用固定秘钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis jwt过期时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims    设置的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成JWT的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置jwt的body</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置过期时间</span></span><br><span class="line">                .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Token解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造, 如果对接多个客户端建议改造成多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     加密后的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">                .parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">login</span><span class="params">(EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> employeeLoginDTO.getUsername();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> employeeLoginDTO.getPassword();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、根据用户名查询数据库中的数据</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.getByUsername(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）</span></span><br><span class="line">        <span class="keyword">if</span> (employee == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//账号不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountNotFoundException</span>(MessageConstant.ACCOUNT_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//密码比对</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(employee.getPassword())) &#123;</span><br><span class="line">            <span class="comment">//密码错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PasswordErrorException</span>(MessageConstant.PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (employee.getStatus() == StatusConstant.DISABLE) &#123;</span><br><span class="line">            <span class="comment">//账号被锁定</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountLockedException</span>(MessageConstant.ACCOUNT_LOCKED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、返回实体对象</span></span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>安全起见，密码不是明文传输，使用<code>DigestUtils.md5DigestAsHex（）</code>进行MD5加密处理</p><h2 id="JwtTokenAdminInterceptor拦截器"><a href="#JwtTokenAdminInterceptor拦截器" class="headerlink" title="JwtTokenAdminInterceptor拦截器"></a>JwtTokenAdminInterceptor拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sky.constant.JwtClaimsConstant;</span><br><span class="line"><span class="keyword">import</span> com.sky.context.BaseContext;</span><br><span class="line"><span class="keyword">import</span> com.sky.properties.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.sky.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jwt令牌校验的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求头中获得token并解析，判断是否有效</p><ul><li>无效，不放行</li><li>有效，拿到token中存入的员工id并存放到ThreadLocal当中</li></ul><h2 id="ThreadLocal封装类"><a href="#ThreadLocal封装类" class="headerlink" title="ThreadLocal封装类"></a>ThreadLocal封装类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个线程都有一个独立的存储空间。此处存放的是当前用户的id，以便后续获取当前登录用户信息。</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 登录 </tag>
            
            <tag> 校验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/KendricW.github.io/2024/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/KendricW.github.io/2024/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>除GOF23种外的设计模式<br>    * 简单工厂模式<br>        * 由一个工厂决定创建哪一种产品类型的实例</p><ul><li><p>创建型模式</p><ul><li>隐藏了创建对象的过程,通过逻辑方法进行创建对象,而不是通过new关键字进行创建<ul><li>工厂方法模式<ul><li>定义一个接口或一个抽象的工厂类,让它实现类(工厂)来决定创建哪一个实例对象</li><li>根据每个工厂不同的方法,来产生不同的所需要的对象</li><li>工厂方法模式生产的都是相同系列的对象,比如Java课程,Python课程</li></ul></li><li>抽象工厂模式<ul><li>抽象工厂模式提供了创建一系列相关或互相依赖对象的接口</li><li>类似公司下的产品,生产,生产汽车,将汽车分为各个零部件进行生产,车架,车门,底盘.</li></ul></li><li>建造者模式<ul><li>将复杂的对象的创建和属性赋值所分离</li><li>监造的过程和细节我们不需要知道,只需要通过构建者去进行操作即可</li></ul></li><li>原型模式<ul><li>用于创建重复的对象,能够保证创建对象的性能.</li><li>原型设计模式是创建对象的最佳方式</li></ul></li><li>单例模式<ul><li>在程序中想要保持一个实力对象的,就是用单例设计模式</li><li>减少内存开销<ul><li>懒汉式<ul><li>在需要使用对象的时候,才会创建</li></ul></li><li>双重检查<ul><li>通过两个if判断,加上同步锁进行实现</li></ul></li><li>静态内部类<ul><li>在单例类中,通过私有的静态内部类,创建单例对象</li></ul></li><li>饿汉式<ul><li>在调用时,就会创建单例对象,通过静态代码块或静态变量直接初始化</li></ul></li><li>枚举<ul><li>枚举的方式实现单例模式,是最佳的实现方式</li><li>它可以有效防止对单例模式的破坏<ul><li>序列化和反序列的方式破坏单例模式<ul><li>通过流将单例对象,序列化到文件中,然后再反序列化读取出来</li><li>最终通过反序列化的方式创建出一个对象</li><li>发现两个对象的内存地址完全不一致,从而破坏了单例设计模式解构</li><li>在单例类中,写一个方法名称必须为readResolve<ul><li>因为在反序列化创建对象时,是通过反射创建的</li><li>反射会调用我们自己的readResolve,方法</li><li>如果重写了,就代表返回自己的单例对象</li><li>如果没有重写,会通过反射的方式创建一个新的对象,从而破坏了单例设计模式  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doubleCheckSingleton;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>通过反射的方式破坏单例模式</li><li>通过字节码对象,创建构造器对象</li><li>通过构造器对象,初始化单例对象</li><li>由于单例对象的构造方法是私有化的</li><li>调用构造器中的方法,赋予权限,创建单例对象</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>结构型模式</p><ul><li>主要关注类和对象的组合关系</li><li>继承的概念被用来组合接口和定义组合对象,获得新的功能方式<ul><li>外观模式<ul><li>提供了一个统一的接口,用来访问子系统中的一群接口</li><li>定义了一个高层接口,让子系统使用更加容易</li></ul></li><li>适配器模式<ul><li>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁,将一个类的接口转换成客户希望的另外一个接口</li><li>适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li><li>这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能</li></ul></li><li>桥接模式<ul><li>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。</li><li>这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</li><li>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</li></ul></li><li>组合模式<ul><li>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。</li><li>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</li><li>这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</li><li>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</li><li>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</li></ul></li><li>代理模式<ul><li>为对象提供一种代理，以控制这个对象的访问操作</li><li>代理对象和目标对象之间起到中介的作用</li><li>保护目标对象和增强目标对象</li><li>代理模式能将代理对象与真实被调用的目标对象分离</li><li>一定程度上降低了系统的耦合度，扩展性好</li></ul></li><li>装饰模式<ul><li>在原有对象不做改变的基础上，将对象的功能附加上</li><li>提供了比继承更有弹性的替代方案(扩展原有对象功能)</li><li>扩展一个类的功能或给一个类添加附加职责(业务逻辑)</li><li>动态的给一个对象添加功能，这些功能可以再动态的撤销</li><li>继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能</li><li>通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果</li></ul></li><li>享元模式<ul><li>提供了减少对象数量从而改善应用所需的对象结构的方式</li><li>运用共享技术有效地支持大量细粒度的对象</li><li>总结：减少创建对象的数量，从而减少内存的占用，提升性能</li></ul></li></ul></li></ul></li><li><p>行为型模式</p><ul><li>主要关注对象之间的通信<ul><li>模板方法模式<ul><li>定义了一个算法的架构，并允许子类为一个或多个步骤的实现</li><li>模板方法在子类不改变算法结构的情况下，重新定义算法的某些步骤</li><li>实现一个算法的不变的部分，并将可变的空间留给子类来完成</li><li>子类中公共的行为抽取出来并封装到一个公共父类中，避免代码重复</li></ul></li><li>迭代器模式<ul><li>提供方法，顺序访问集合对象中的各个元素，而又不暴露对象的内部表示</li><li>为遍历不同的集合结构提供统一的接口,分离了集合对象的遍历行为</li></ul></li><li>策略模式<ul><li>定义了算法，分别封装起来，它们之间可以相互替换，让算法的变化不会影响到使用算法的用户</li><li>如果有大量的if…else…else if…可以通过策略模式进行替换</li><li>避免使用多重条件转语句，if…else if…else</li><li>提高算法的保密性和安全性</li></ul></li><li>解释器模式<ul><li>通过给定的语言，定义它的语法和行为，并定义解释器，这个解释器使用来解释语言中的句子</li><li>为了解释一种语言，而为语言创建的解释器<ul><li>某个类型问题触发频次足够高,比如处理日志和不同日志格式</li></ul></li></ul></li><li>观察者模式<ul><li>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）</li><li>比如，当一个对象被修改时，则会自动通知依赖它的对象。</li><li>让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者(观察者)都会收到通知并更新</li></ul></li><li>备忘录模式<ul><li>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li><li>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</li><li>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</li></ul></li><li>命令模式<ul><li>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。解决了应用程序中对象的职责以及它们之间的通信方式</li><li>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</li><li>请求调用者和行为实现者需要解耦，使得调用者和行为实现者不直接交互</li></ul></li><li>中介者模式<ul><li>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</li><li>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</li></ul></li><li>责任链模式<ul><li>为请求创建了一个接收者对象的链。对请求的发送者和接收者进行解耦。</li><li>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</li><li>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</li><li>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</li></ul></li><li>访问者模式<ul><li>使用一个访问者类，它改变了元素类的执行算法。</li><li>通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。</li><li>根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</li><li>主要将数据结构与数据操作分离。稳定的数据结构和易变的操作耦合问题。</li></ul></li><li>状态模式<ul><li>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</li><li>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</li><li>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字母异位词分组</title>
      <link href="/KendricW.github.io/2024/03/12/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
      <url>/KendricW.github.io/2024/03/12/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><h2 id="题解1（质数）"><a href="#题解1（质数）" class="headerlink" title="题解1（质数）"></a><strong>题解1（质数）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, Integer&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">        put(<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// ... 省略其他字符和对应的数值</span></span><br><span class="line">        put(<span class="string">&#x27;z&#x27;</span>, <span class="number">101</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; resMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                hash *= MAP.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!resMap.containsKey(hash)) &#123;</span><br><span class="line">                resMap.put(hash, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            resMap.get(hash).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resMap.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解2（stream流）"><a href="#题解2（stream流）" class="headerlink" title="题解2（stream流）"></a><strong>题解2（stream流）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定字符串数组按照其中每个字符串的字母异位词进行分组，并返回一个包含这些分组的列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 输入的字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个列表，其中每个元素是属于同一字母异位词组的字符串列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">                Arrays.stream(strs)</span><br><span class="line">                        <span class="comment">// 使用sortedCharsToString方法将每个字符串转换为它的排序后字符表示，以此作为分组键</span></span><br><span class="line">                        .collect(Collectors.groupingBy(<span class="built_in">this</span>::sortedCharsToString))</span><br><span class="line">                        <span class="comment">// 取得所有分组值（即每个组内的字符串集合）</span></span><br><span class="line">                        .values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有辅助方法，接收一个字符串参数并返回其内部字符经过排序后的字符串形式。</span></span><br><span class="line"><span class="comment">     * 这个方法用于识别和区分字母异位词。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串s中所有字符按字典序排序后的新字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">sortedCharsToString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符流，排序后构建新的字符串</span></span><br><span class="line">        <span class="keyword">return</span> s.chars()</span><br><span class="line">                .sorted()</span><br><span class="line">                .collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::appendCodePoint, StringBuilder::append)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解3（官方）"><a href="#题解3（官方）" class="headerlink" title="题解3（官方）"></a><strong>题解3（官方）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个字符串数组，将其中的字母异位词分组并返回结果列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组，包含多个可能为字母异位词的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个List&lt;List&lt;String&gt;&gt;类型的对象，每个内部列表代表一组字母异位词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap来存储字母异位词分组，键是排序后的字符组成的字符串，值是一个字符串列表</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输入的字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="comment">// 将当前字符串转换为字符数组</span></span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对字符数组进行排序，使得所有相同字母异位词在排序后得到相同的字符序列</span></span><br><span class="line">            Arrays.sort(array);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将排序后的字符数组转换回字符串作为哈希表的键</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取或初始化与当前键关联的字符串列表（若不存在则创建一个新的ArrayList）</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向对应的列表中添加原始的字符串</span></span><br><span class="line">            list.add(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新映射表，将排序后字符串对应的列表存入键值对中</span></span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将映射表中的所有值（即每组字母异位词的列表）转换为一个新的ArrayList，并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="/KendricW.github.io/2024/03/12/%E7%AE%97%E6%B3%95-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/KendricW.github.io/2024/03/12/%E7%AE%97%E6%B3%95-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="移动零（简单）"><a href="#移动零（简单）" class="headerlink" title="移动零（简单）"></a>移动零（简单）</h1><p>[toc]</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 移动零 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//如果数组是空的直接返回，不浪费时间</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录非零的数目</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一次遍历的时候，只要是非0的统统都赋给nums[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将后面的数补0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://big-event-wzx.oss-cn-beijing.aliyuncs.com/image-20240312002556724.png" alt="成果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/KendricW.github.io/2024/03/10/hello-world/"/>
      <url>/KendricW.github.io/2024/03/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
