<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis消息队列</title>
      <link href="/KendricW.github.io/2024/04/23/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/KendricW.github.io/2024/04/23/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>Redis提供了三种不同的方式来实现消息队列：</p><ul><li>list结构：基于List结构模拟消息队列</li><li>PubSub：基本的点对点消息模型</li><li>Stream：比较完善的消息队列模型</li></ul><h2 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h2><p>LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><hr><h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><hr><h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><p>Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词汇量积累</title>
      <link href="/KendricW.github.io/2024/04/19/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"/>
      <url>/KendricW.github.io/2024/04/19/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="2024年4月19日"><a href="#2024年4月19日" class="headerlink" title="2024年4月19日"></a>2024年4月19日</h1><h2 id="bull"><a href="#bull" class="headerlink" title="bull"></a>bull</h2><ul><li>公牛</li></ul><h2 id="pot"><a href="#pot" class="headerlink" title="pot"></a>pot</h2><ul><li>锅，罐，壶<ul><li>hot pot 火锅</li><li>keep the pot boling 谋生，维持生活</li><li>a bit pot 大人物</li><li>coffee pot 咖啡壶</li><li>flower pot 花盆</li></ul></li></ul><h2 id="intimate"><a href="#intimate" class="headerlink" title="intimate"></a>intimate</h2><ul><li>形容词 亲密的 密切的 详细的</li><li>名词 知己 密友</li><li>动词 暗示 宣布 通知<ul><li>intimate relationship 亲密的关系</li><li>intimate contact 亲密接触</li><li>intimate distance 亲密距离</li><li>intimate service 贴心服务</li></ul></li></ul><h2 id="chew"><a href="#chew" class="headerlink" title="chew"></a>chew</h2><ul><li>动词 咀嚼 嚼碎</li><li>名词 咀嚼<ul><li>chew gum 口香糖</li><li>chew up 嚼碎 毁坏 消耗</li><li>chew over 仔细思考</li></ul></li></ul><h2 id="hatch"><a href="#hatch" class="headerlink" title="hatch"></a>hatch</h2><ul><li>动词 孵蛋 破壳 策划 密谋</li><li>名词 船舱盖<ul><li>hatch out 孵化 策划</li><li>hatch into 孵化成</li><li>escape hatch 安全舱口</li></ul></li></ul><h2 id="disguise"><a href="#disguise" class="headerlink" title="disguise"></a>disguise</h2><ul><li>名词 伪装物 伪装 伪装用具</li><li>动词 伪装 掩盖 假扮<ul><li>in disguise 伪装</li></ul></li></ul><h2 id="bore"><a href="#bore" class="headerlink" title="bore"></a>bore</h2><ul><li><p>名词 讨厌的人 高潮 口径 孔</p></li><li><p>动词 使厌烦 稳步向前 钻空</p><ul><li>bore hole 钻空 炮眼</li><li>bore out 证实 显出</li><li>bore 孔径</li><li>bore 全孔射击</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/KendricW.github.io/2024/04/10/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/KendricW.github.io/2024/04/10/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><h2 id="基本原理和实现方式对比"><a href="#基本原理和实现方式对比" class="headerlink" title="基本原理和实现方式对比"></a>基本原理和实现方式对比</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/15/8e5a532b0b44e803.png"></p><h2 id="分布式锁应该满足哪些条件？"><a href="#分布式锁应该满足哪些条件？" class="headerlink" title="分布式锁应该满足哪些条件？"></a>分布式锁应该满足哪些条件？</h2><ul><li>可见性：多个线程都能看到相同的结果<ul><li>注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个线程之间都能感知到变化的意思</li></ul></li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻到保证较高的可用性</li><li>高性能：加锁会让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全是必不可少的一环</li></ul><h2 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h2><ul><li><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p></li><li><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p></li><li><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案</p></li></ul><p><img src="https://s3.bmp.ovh/imgs/2024/04/15/5dc30fa93f28f484.png"></p><h2 id="Redis分布式锁的实现核心思路"><a href="#Redis分布式锁的实现核心思路" class="headerlink" title="Redis分布式锁的实现核心思路"></a>Redis分布式锁的实现核心思路</h2><p>实现分布式锁时需要实现的两个基本方法</p><ul><li><p>获取锁：</p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul></li><li><p>释放锁：</p><ul><li>手动释放</li><li>超时释放：获取锁时添加一个超时时间</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//释放锁，删除即可</span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/16/d0d331b07f4cc163.png"></p><h3 id="实现分布式锁代码实现"><a href="#实现分布式锁代码实现" class="headerlink" title="实现分布式锁代码实现"></a>实现分布式锁代码实现</h3><p><strong>SimpleRedisLock</strong></p><p>利用setnx方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX=<span class="string">&quot;lock:&quot;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId()</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">            .setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放锁逻辑</li></ul><p>SimpleRedisLock</p><p>释放锁，防止删除别人的锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//通过del删除锁</span></span><br><span class="line">    stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改业务代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1.查询优惠券</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">      <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 尚未开始</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">      <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 库存不足</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      <span class="comment">//创建锁对象(新增代码)</span></span><br><span class="line">      <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(<span class="string">&quot;order:&quot;</span> + userId, stringRedisTemplate);</span><br><span class="line">      <span class="comment">//获取锁对象</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">          <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">          <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Redis分布式锁误删情况说明"><a href="#Redis分布式锁误删情况说明" class="headerlink" title="Redis分布式锁误删情况说明"></a>Redis分布式锁误删情况说明</h2><p>逻辑说明：</p><p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明</p><p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/16/635d3f26c234b05b.png"></p><h2 id="解决Redis分布式锁误删问题"><a href="#解决Redis分布式锁误删问题" class="headerlink" title="解决Redis分布式锁误删问题"></a>解决Redis分布式锁误删问题</h2><p>需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用UUID表示）<br>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p><ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul><p>核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/16/6a78ac9d0a611ef4.png"></p><p>具体代码如下：加锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">   <span class="comment">// 获取线程标示</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 获取锁中的标示</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">    <span class="comment">// 判断标示是否一致</span></span><br><span class="line">    <span class="keyword">if</span>(threadId.equals(id)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分布式锁的原子性问题"><a href="#分布式锁的原子性问题" class="headerlink" title="分布式锁的原子性问题"></a>分布式锁的原子性问题</h2><p>更为极端的误删逻辑说明：</p><p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/16/02a58e5979aeb079.png"></p><h2 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h2><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a href="https://www.runoob.com/lua/lua-tutorial.html%EF%BC%8C%E8%BF%99%E9%87%8C%E9%87%8D%E7%82%B9%E4%BB%8B%E7%BB%8DRedis%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8lua%E5%8E%BB%E6%93%8D%E4%BD%9Credis%EF%BC%8C%E5%8F%88%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BB%96%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8B%BF%E9%94%81%E6%AF%94%E9%94%81%E5%88%A0%E9%94%81%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%80%A7%E5%8A%A8%E4%BD%9C%E4%BA%86%EF%BC%8C%E4%BD%9C%E4%B8%BAJava%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%99%E4%B8%80%E5%9D%97%E5%B9%B6%E4%B8%8D%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%A6%81%E6%B1%82%E3%80%82">https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为Java程序员这一块并不作一个简单要求。</a></p><p>这里重点介绍Redis提供的调用函数，语法如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p>例如，我们要执行set name jack，则脚本是这样：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure><p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"># 先执行 set name jack</span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"># 再执行 get name</span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"># 返回</span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">#调用脚本</span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot;</span> <span class="number">1</span> name Rose</span><br></pre></td></tr></table></figure><p>释放锁的业务流程是这样的</p><p>​1、获取锁中的线程标示</p><p>​2、判断是否与指定的标示（当前线程标示）一致</p><p>​3、如果一致则释放锁（删除）</p><p>​4、如果不一致则什么都不做</p><p>如果用Lua脚本来表示则是这样的：</p><p>最终我们操作redis的拿锁比锁删锁的lua脚本就会变成这样</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="利用Java代码调用Lua脚本改造分布式锁"><a href="#利用Java代码调用Lua脚本改造分布式锁" class="headerlink" title="利用Java代码调用Lua脚本改造分布式锁"></a>利用Java代码调用Lua脚本改造分布式锁</h2><p>lua脚本本身并不需要大家花费太多时间去研究，只需要知道如何调用，大致是什么意思即可，所以在笔记中并不会详细的去解释这些lua表达式的含义。</p><p>我们的RedisTemplate中，可以利用execute方法去执行lua脚本，参数对应关系就如下图股</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/17/1fcd5be794a4deb9.png" alt="1fcd5be794a4deb9.png"></p><p><strong>Java代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure><p>小总结：</p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><p>笔者总结：我们一路走来，利用添加过期时间，防止死锁问题的发生，但是有了过期时间之后，可能出现误删别人锁的问题，这个问题我们开始是利用删之前 通过拿锁，比锁，删锁这个逻辑来解决的，也就是删之前判断一下当前这把锁是否是属于自己的，但是现在还有原子性问题，也就是我们没法保证拿锁比锁删锁是一个原子性的动作，最后通过lua表达式来解决这个问题</p><p>但是目前还剩下一个问题锁不住，什么是锁不住呢，你想一想，如果当过期时间到了之后，我们可以给他续期一下，比如续个30s，就好像是网吧上网， 网费到了之后，然后说，来，网管，再给我来10块的，是不是后边的问题都不会发生了，那么续期问题怎么解决呢，可以依赖于我们接下来要学习redission啦</p><p><strong>测试逻辑：</strong></p><p>第一个线程进来，得到了锁，手动删除锁，模拟锁超时了，其他线程会执行lua来抢锁，当第一天线程利用lua删除锁时，lua能保证他不能删除他的锁，第二个线程删除锁时，利用lua同样可以保证不会删除别人的锁，同时还能保证原子性。</p><hr><h1 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h1><h2 id="分布式锁-redission功能介绍"><a href="#分布式锁-redission功能介绍" class="headerlink" title="分布式锁-redission功能介绍"></a>分布式锁-redission功能介绍</h2><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p><img src="https://vip.helloimg.com/i/2024/04/17/661ea7e45a3ed.png" alt="661ea7e45a3ed.png"></p><p>那么什么是Redission呢</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="https://vip.helloimg.com/i/2024/04/17/661ea90476505.png"></p><h2 id="Redission快速入门"><a href="#Redission快速入门" class="headerlink" title="Redission快速入门"></a>Redission快速入门</h2><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.13</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.150.101:6379&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 VoucherOrderServiceImpl</p><p>注入RedissonClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 尚未开始</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存不足</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//创建锁对象 这个代码不用了，因为我们现在要使用分布式锁</span></span><br><span class="line">        <span class="comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line">        <span class="comment">//获取锁对象</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">       </span><br><span class="line"><span class="comment">//加锁失败</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取代理对象(事务)</span></span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑过期解决缓存击穿问题</title>
      <link href="/KendricW.github.io/2024/04/10/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
      <url>/KendricW.github.io/2024/04/10/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑过期解决缓存击穿问题"><a href="#逻辑过期解决缓存击穿问题" class="headerlink" title="逻辑过期解决缓存击穿问题"></a>逻辑过期解决缓存击穿问题</h1><p><strong>需求：修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p><p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/10/d02db922b6ace937.png"></p><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>新建一个实体类，对原来到吗没有侵入性。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询店铺数据</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2. 封装逻辑过期时间</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">    redisData.setData(shop);</span><br><span class="line">    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">    <span class="comment">// 3. 写入Redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p><strong>ShopServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装-Redis-工具类"><a href="#封装-Redis-工具类" class="headerlink" title="封装 Redis 工具类"></a>封装 Redis 工具类</h2><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</p></li><li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</p></li><li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</p></li><li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</p></li></ul><p>将逻辑进行封装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        <span class="comment">// 写入Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            <span class="comment">// 6.3.成功，开启独立线程，实现缓存重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">newR</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, newR, time, unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithMutex</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopJson, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.实现缓存重建</span></span><br><span class="line">        <span class="comment">// 4.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">// 4.2.判断是否获取成功</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                <span class="comment">// 4.3.获取锁失败，休眠并重试</span></span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.4.获取锁成功，根据id查询数据库</span></span><br><span class="line">            r = dbFallback.apply(id);</span><br><span class="line">            <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将空值写入redis</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="comment">// 返回错误信息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">            <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7.释放锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8.返回</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ShopServiceImpl 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CacheClient cacheClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 解决缓存穿透</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互斥锁解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithMutex(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑过期解决缓存击穿</span></span><br><span class="line">        <span class="comment">// Shop shop = cacheClient</span></span><br><span class="line">        <span class="comment">//         .queryWithLogicalExpire(CACHE_SHOP_KEY, id, Shop.class, this::getById, 20L, TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存击穿 </tag>
            
            <tag> 互斥锁 </tag>
            
            <tag> 逻辑过期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互斥锁解决缓存击穿问题</title>
      <link href="/KendricW.github.io/2024/04/09/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
      <url>/KendricW.github.io/2024/04/09/%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="互斥锁解决缓存击穿问题"><a href="#互斥锁解决缓存击穿问题" class="headerlink" title="互斥锁解决缓存击穿问题"></a>互斥锁解决缓存击穿问题</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>相较于原来重缓存中查询不到数据后直接查询数据库而言，现在的方案是进行查询后，如果缓存没有查询到数据，则进行互斥锁的的获取，获取互斥锁后，判断是否获得了锁，如果没有获得到，则休眠，过一会儿再尝试查询，直到获取锁为止，才能进行查询。</p><p>如果获取到了锁的线程，再去进行查询，查询后将数据写入redis，再释放锁，返回数据，利用互斥锁就能保证只有一个线程去执行操作数据库的逻辑，防止缓存击穿</p><p><img src="https://s3.bmp.ovh/imgs/2024/04/10/1f54c2b678abb6e1.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>核心思路就是利用redis的setnx方法来表示获取锁，该方法含义是redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true，  如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false，我们可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程我们认为他就是获得到锁的线程。</p><p>操作锁的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>  &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">// 1、从redis中查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">       <span class="comment">// 2、判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">// 存在,直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断命中的值是否是空值</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回一个错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">            shop = getById(id);</span><br><span class="line">           <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">               <span class="comment">//返回错误信息</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unlock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存击穿 </tag>
            
            <tag> 互斥锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短信登录及状态更新</title>
      <link href="/KendricW.github.io/2024/04/07/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
      <url>/KendricW.github.io/2024/04/07/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="短信登录及状态更新"><a href="#短信登录及状态更新" class="headerlink" title="短信登录及状态更新"></a>短信登录及状态更新</h1><h2 id="基于-Session-实现登录流程"><a href="#基于-Session-实现登录流程" class="headerlink" title="基于 Session 实现登录流程"></a>基于 Session 实现登录流程</h2><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p><p>具体逻辑上文已经分析，我们仅仅只需要按照提示的逻辑写出代码即可。</p><ul><li>发送验证码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>登录</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让拦截器生效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p><p><strong>在登录方法处修改</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure><p><strong>在拦截器处：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure><p><strong>在UserHolder处：将user对象换成UserDTO</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-代替-session-的业务流程"><a href="#Redis-代替-session-的业务流程" class="headerlink" title="Redis 代替 session 的业务流程"></a>Redis 代替 session 的业务流程</h2><h3 id="设计-key-的结构"><a href="#设计-key-的结构" class="headerlink" title="设计 key 的结构"></a>设计 key 的结构</h3><p>我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了</p><p>在设计这个key的时候，我们之前讲过需要满足两点</p><ol><li><p>key要具有唯一性</p></li><li><p>key要方便携带</p></li></ol><p>如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了</p><h3 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h3><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p><h2 id="基于-Redis-实现短信登录"><a href="#基于-Redis-实现短信登录" class="headerlink" title="基于 Redis 实现短信登录"></a>基于 Redis 实现短信登录</h2><p><strong>UserServiceImpl代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">        <span class="comment">// 不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">    <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">            CopyOptions.create()</span><br><span class="line">                    .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                    .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line">    <span class="comment">// 7.3.存储</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">    <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.返回token</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RefreshTokenInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span>  <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">// 3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>LoginInterceptor</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有，需要拦截，设置状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有用户，则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 登录 </tag>
            
            <tag> 短信 </tag>
            
            <tag> 状态更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/KendricW.github.io/2024/04/05/Mysql%20%E7%B4%A2%E5%BC%95/"/>
      <url>/KendricW.github.io/2024/04/05/Mysql%20%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-索引"><a href="#Mysql-索引" class="headerlink" title="Mysql 索引"></a>Mysql 索引</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>索引是一种用于快 速查询和检索数据的数据结构，其本质可以看成一个排列好的数据结构。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>：</p><ul><li>大大加快数据的检索数独（减少检索的数据量），减少 IO 次数，最主要的原因</li><li>通过创建唯一性索引，可以保证数据库中每一行数据的唯一性</li></ul><p><strong>缺点</strong>：</p><ul><li>创建索引和维护索引需要耗费许多时间，当对表中的数据进行增删改的时候，如果没有索引，那么索引也需要动态的修改，会降低 SQL 执行效率</li><li>索引需要使用物理文件存储，也会耗费一定空间</li></ul><p>但是，使用索引一定能提高查询效率吗？</p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h2 id="B-树-B-树"><a href="#B-树-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h2><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li><li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li></ul><p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p><h2 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h2><ul><li>不为 null 的字段：较难优化数据为 NULL 的字段，建议改成 0,1，true，false 寓意清晰的数据</li><li>被频繁查询的字段</li><li>被作为条件查询的字段</li><li>频繁需要排序的字段：加快排序的时间</li><li>被经常频繁用于连接的字段：提高多表连接查询的效率</li></ul><h2 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="被频繁更新的字段应该慎重建立索引"></a>被频繁更新的字段应该慎重建立索引</h2><p>维护索引的成本是不小的，需要重新建立排序</p><h2 id="限制每张表上的索引数量"><a href="#限制每张表上的索引数量" class="headerlink" title="限制每张表上的索引数量"></a>限制每张表上的索引数量</h2><p>建议单表索引不超过5个！！！</p><p>索引可以提高效率同样也可以降低效率</p><h2 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h2><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的，如果是联合索引，多个字段在一个索引上，那么将会节约很大的磁盘空间，且修改数据的操作效率也会提升。</p><h2 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h2><p>冗余索引指的是索引功能相同，能够命中索引（a，b）就肯定能命中索引 a，那么索引 a 就是冗余索引。</p><h2 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h2><ul><li>创建了组合索引，单查询条件为遵守最左匹配原则</li><li>在索引上进行计算，函数，类型转换等操作</li><li>也 % 开头的 LIKE 查询</li><li>查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</li><li>is null 可以使用索引，但是 is not null 无法使用索引</li></ul><h2 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h2><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p><p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。 </p><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>各个字段的含义如下：</p><table><thead><tr><th><strong>列名</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的序列标识符</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的查询类型</td></tr><tr><td>table</td><td>用到的表名</td></tr><tr><td>partitions</td><td>匹配的分区，对于未分区的表，值为 NULL</td></tr><tr><td>type</td><td>表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际用到的索引</td></tr><tr><td>key_len</td><td>所选索引的长度</td></tr><tr><td>ref</td><td>当使用索引等值查询时，与索引作比较的列或常量</td></tr><tr><td>rows</td><td>预计要读取的行数</td></tr><tr><td>filtered</td><td>按表条件过滤后，留存的记录数的百分比</td></tr><tr><td>Extra</td><td>附加信息</td></tr></tbody></table><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>select查询的序列号，表示查询中执行select子句或操作表的顺序<br>id相同时，执行顺序由上至下<br>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，则先被执行<br>id相同和不同都存在是，id相同的可以理解为一组，从上往下顺序执行，所有组中，id值越大，优先级越高越先执行。</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>simple：简单的select查询，查询中不包含子查询或者union<br>primary：查询中若包含任何复杂的子部分，最外层查询则被标记为primary<br>derived：在from列表中包含的子查询被标记为derived（衍生），mysql会递归执行这些子查询，把结果放在临时表里。<br>subquery：在select或where列表中包含了子查询。<br>table：显示这一行的数据是关于哪张表的</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p><p>const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，mysql就能将该查询转换为一个常量。</p><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该数据查找和扫描的混合体。</p><p>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p><p>index：full index scan，index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小，也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。</p><p>all：full table scan，将遍历全表以找到匹配的行。<br>从最好到最差依次是<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all</strong>。一般来说，最好保证查询能达到range级别，最好能达到ref。</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上如果存在索引，则该索引将会被列出来，但不一定会被查询实际使用上。</p><p>key:查询中实际使用的索引，如果为null，则没有使用索引</p><p>ref：显示索引的哪一列被使用了，哪些列或常量被用于查找索引列上的值</p><p>rows:rows列显示MySQL认为它执行查询时必须检查的行数，一般越少越好。</p><h3 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h3><p>using filesort：MySQL无法利用索引完成的排序操作称为“文件排序”（排序时没有使用索引，需要优化）</p><p>Using temporary：MySQL在对查询结果排序时使用临时表，常见于排序order by和分组查询group by。（分组时没有使用索引，需要优化）</p><p>Using index：表示索引被用来执行行索引键值的查找，避免访问了表的数据行，效率不错。</p><p>Using where：表示使用了where过滤。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁</title>
      <link href="/KendricW.github.io/2024/03/31/Mysql%E9%94%81/"/>
      <url>/KendricW.github.io/2024/03/31/Mysql%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql-各种锁"><a href="#Mysql-各种锁" class="headerlink" title="Mysql 各种锁"></a>Mysql 各种锁</h1><h2 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a>粒度锁</h2><p>Mysql 的锁定主要分为全局锁、表锁和行锁</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ol><li><code>读锁</code>（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。保持一段时间内的数据一致性时很有用。</li><li><code>写锁</code>（排他锁）：它阻止其他用户读取和更新数据。在修改大量数据，并不希望其他用户来干扰的这段时间很有用。</li></ol><p>使用场景：全库备份、全库导出、全库只读</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH TABLES WITH READ LOCK (FTWRL)</span><br><span class="line">UNLOCK TABLES</span><br></pre></td></tr></table></figure><ul><li>全局锁的开销非常大，因为会阻止其他所有的数据修改操作，并且在高并发情况下可能导致大量的线程等待锁定。因此应该避免在生产环境中使用全局锁，或者尽量减少全局所的持有时间</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ol><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ol><p>在 Mysql 中，对 MyISAM 表的读操作，会自动加上读锁，写亦是如此</p><p>适用于读多写少，并发争用不是很激烈</p><p>使用场景：读密集型应用、写操作不频繁、数据量不大、全表更新或删除</p><p>开销较小但是锁的粒度大，并发能力低，不适合高并发</p><h4 id="哪些命令会发生表级锁"><a href="#哪些命令会发生表级锁" class="headerlink" title="哪些命令会发生表级锁"></a>哪些命令会发生表级锁</h4><ol><li><strong>ALTER TABLE</strong>：当对表结构进行修改时，如添加、删除列或者索引，或者更改表的存储引擎等操作，MySQL会对整张表施加表级锁。</li><li><strong>LOCK TABLES</strong>：这是一个显式的加锁命令，可以通过指定<code>READ</code>或<code>WRITE</code>模式来对表进行加锁。例如，<code>LOCK TABLES t1 READ</code>会对表<code>t1</code>施加共享锁，而<code>LOCK TABLES t1 WRITE</code>则会施加排他锁。</li><li><strong>REPAIR TABLE</strong>：当执行表修复操作时，MySQL会对表施加锁，以防止在修复过程中数据被修改。</li><li><strong>OPTIMIZE TABLE</strong>：执行表优化操作时，MySQL也会对表施加锁，以确保在优化过程中表的数据不会被更改。</li><li><strong>DELETE</strong>、<strong>INSERT</strong>、<strong>UPDATE</strong>：虽然这些操作通常与行级锁相关，但在某些情况下，如果存储引擎不支持行级锁，或者操作涉及到全表扫描，MySQL可能会对表施加表级锁。</li><li><strong>SELECT … FOR UPDATE</strong> 和 <strong>SELECT … LOCK IN SHARE MODE</strong>：这两个查询提示可以用于显式地对查询结果施加行级锁或共享锁，但如果查询条件没有使用索引，或者存储引擎不支持行级锁，MySQL可能会回退到使用表级锁。</li></ol><h4 id="风险点"><a href="#风险点" class="headerlink" title="风险点"></a>风险点</h4><ol><li>性能下降</li><li>并发能力差</li><li>可能导致锁等待和超时</li><li>写操作影响大</li><li>死锁的可能性：多标操作中，如果没有按照一定的顺序获得锁，可能会导致死锁</li></ol><p>为了避免这些问题，通常会选择 InnoDB 存储引擎，它主要使用行级锁，可以提供更好的并发性能，一定程度上较少了锁争用的问题，而且还支持事物，可以保证数据的一致性和完整性。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>单行锁定，粒度小，更好的并发性能和更少的锁冲突。</p><p>需要更多的内存和 CPU 资源，因为每一行都需要管理。</p><ol><li>共享锁（S 锁）</li><li>排他锁（X 锁）</li></ol><p>实际使用中，InnoDB 还提供了一种间隙锁的特性。</p><p>值得注意的是，行级锁只在事务中有效。</p><p>使用场景</p><ul><li>高并发读写</li><li>单行操作</li><li>短期锁</li><li>实现并发控制</li><li>复杂事务处理</li></ul><h4 id="哪些命令会发生表级锁-1"><a href="#哪些命令会发生表级锁-1" class="headerlink" title="哪些命令会发生表级锁"></a>哪些命令会发生表级锁</h4><ol><li><p><strong>SELECT … FOR UPDATE</strong>: 这个命令用于锁定查询结果中的行，以便进行更新操作。它对查询到的行加上排他锁（X锁），阻止其他事务对这些行进行修改或加排他锁，直到当前事务完成（提交或回滚）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition FOR UPDATE;</span><br></pre></td></tr></table></figure></li><li><p><strong>SELECT … LOCK IN SHARE MODE</strong>: 这个命令用于锁定查询结果中的行，以便进行共享读取操作。它对查询到的行加上共享锁（S锁），阻止其他事务对这些行加排他锁，但允许其他事务对这些行加共享锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure></li><li><p><strong>UPDATE</strong>: 当执行更新操作时，InnoDB会对涉及的行加上排他锁（X锁），防止其他事务对这些行进行修改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name SET column_name = value WHERE condition;</span><br></pre></td></tr></table></figure></li><li><p><strong>DELETE</strong>: 删除操作也会对涉及的行加上排他锁（X锁），确保删除的行不能被其他事务修改。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure></li><li><p><strong>INSERT</strong>: 在执行插入操作时，如果插入的行是基于索引的，InnoDB会对这些行加上排他锁（X锁）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</span><br></pre></td></tr></table></figure></li><li><p><strong>REPLACE</strong>: REPLACE命令类似于INSERT，但如果插入的行的索引键已存在，则先删除旧行再插入新行，这个过程中会对涉及的行加上排他锁（X锁）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制</span><br><span class="line">REPLACE INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</span><br></pre></td></tr></table></figure></li></ol><h4 id="风险点-1"><a href="#风险点-1" class="headerlink" title="风险点"></a>风险点</h4><ol><li>锁升级</li><li>死锁</li><li>锁等待</li><li>资源消耗</li><li>难以调试和排查</li><li>事务隔离级别</li></ol><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>在表中加一个关于版本的字段，可以是时间戳也可以是版本号，在做修改操作的时候，对比版本号是否一致</p><p>使用场景</p><ul><li>低冲突环境</li><li>读多写少</li><li>短事务操作</li><li>分布式系统：网络延迟</li><li>互联网应用：多数是读取，修改同一数据几率较小</li></ul><p>缺点</p><ul><li>冲突检测：在高并发的环境中，乐观锁可能会导致大量的冲突。因为乐观锁只有提交事务时才检查是否有冲突，如果多个事物同一时间操作同一行，只有一个事务能提交成功，其他的事务都要大量的回滚并且重新尝试</li><li>处理开销：大量的回滚和重试，这会增加系统的开销，导致性能下降</li><li>版本管理：乐观锁通常通过版本号来检测冲突，这要求系统能正确地管理这些版本号</li><li>编程复杂性：更复杂的编程</li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>为了保证数据的完整性和一致性，每次在读写数据时都会先加锁，避免其他事务惊醒并发的读写操作</p><p>使用场景：</p><ul><li>写操作多的场景：预先加锁确保数据的完整性和一致性</li><li>并发冲突高的场景</li><li>有特务需要强一致的场景</li></ul><p>值得注意的是，悲观锁也可能引入死锁的问题和锁定过程中事务长时间等待而影响性能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UODATE</span><br><span class="line">SELETE ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>性能开销</li><li>并发度降低</li><li>死锁</li><li>锁超时</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识整合</title>
      <link href="/KendricW.github.io/2024/03/28/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88/"/>
      <url>/KendricW.github.io/2024/03/28/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="面试知识整合"><a href="#面试知识整合" class="headerlink" title="面试知识整合"></a>面试知识整合</h1><h2 id="Lua脚本是干什么的"><a href="#Lua脚本是干什么的" class="headerlink" title="Lua脚本是干什么的"></a>Lua脚本是干什么的</h2><ul><li>Redis等数据库系统支持使用Lua编写脚本直接在数据库内部执行，这样可以实现原子操作，减少网络延迟，并且能够替代或者增强原生的事务处理功能。</li><li>Lua 可替代 XML、INI 等传统配置文件格式，提供更丰富的配置选项和运行时计算能力。</li></ul><hr><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><hr><h2 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h2><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><hr><h2 id="Dubbo与Spring-Cloud有什么区别？"><a href="#Dubbo与Spring-Cloud有什么区别？" class="headerlink" title="Dubbo与Spring Cloud有什么区别？"></a>Dubbo与Spring Cloud有什么区别？</h2><p>Dubbo最初是一个RPC框架，但现在已经发展成为一个微服务框架，在RPC方面，Dubbo在性能和扩展性方面表现出色，支持HTTP2和GRPC。</p><p>而Spring Cloud整个生态系统方面更完善，但Dubbo的生态也在不断发展，Dubbo支持云原生相关功能，而Spring Cloud也在朝这个方向发展。</p><p>在组件版本管理方面，Dubbo更方便。</p><hr><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>多个进程&#x2F;线程同时被阻塞，他们中的一个或者全部都在等某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止</p><h3 id="死锁案例"><a href="#死锁案例" class="headerlink" title="死锁案例"></a>死锁案例</h3><p>假设有两个进程 A 和 B，以及两个资源 X 和 Y，它们的分配情况如下：</p><table><thead><tr><th>进程</th><th>占用资源</th><th>需求资源</th></tr></thead><tbody><tr><td>A</td><td>X</td><td>Y</td></tr><tr><td>B</td><td>Y</td><td>X</td></tr></tbody></table><p>此时，进程 A 占用资源 X 并且请求资源 Y，而进程 B 已经占用了资源 Y 并请求资源 X。两个进程都在等待对方释放资源，无法继续执行，陷入了死锁状态。</p><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ol><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有</li><li><strong>非抢占</strong>：资源不能被抢占</li><li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ol><p><strong>注意 ⚠️</strong>：这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li><p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p></li><li><p><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p></li><li><p><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p></li><li><p><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong></p></li></ul><h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p><p>破坏第三个条件 <strong>非抢占</strong>：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所有的资源，会导致 <strong>资源利用率下降</strong>。</p><p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p><p><strong>1、静态分配策略</strong></p><p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p><p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p><p><strong>2、层次分配策略</strong></p><p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。</p><hr><h2 id="谈谈你对AQS的理解"><a href="#谈谈你对AQS的理解" class="headerlink" title="谈谈你对AQS的理解"></a>谈谈你对AQS的理解</h2><p>AQS是多线程同步器，它是JUC包中多个组件的底层实现，如 Lock、CountDownLatch、Semaphore 等都用到了 AQS</p><p>从本质上来说，AQS 提供了两种锁机制，分别是<strong>排它锁</strong>，和 <strong>共享锁</strong>。</p><p><strong>排它锁</strong>，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock<strong>重入锁</strong>实现就是用到了AQS中的排它锁功能。</p><p><strong>共享锁</strong>也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。</p><hr><h2 id="fail-safe机制与fail-fast机制分别有什么作用"><a href="#fail-safe机制与fail-fast机制分别有什么作用" class="headerlink" title="fail-safe机制与fail-fast机制分别有什么作用"></a>fail-safe机制与fail-fast机制分别有什么作用</h2><p>fail-safe和fail-fast，是多线程并发操作集合时的一种失败处理机制。</p><h3 id="Fail-fast"><a href="#Fail-fast" class="headerlink" title="Fail-fast"></a>Fail-fast</h3><p> 表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻ConcurrentModificationException 异常，从而导致遍历失败。</p><p>定义一个 Map 集合，使用 Iterator 迭代器进行数据遍历，在遍历过程中，对集合数据做变更时，就会发生 fail-fast。</p><p>java.util 包下的集合类都是快速失败机制的, 常见的的使用 fail-fast 方式遍历的容器有HashMap 和 ArrayList 等</p><h3 id="Fail-safe"><a href="#Fail-safe" class="headerlink" title="Fail-safe"></a>Fail-safe</h3><p>表示失败安全，也就是在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException。</p><p>原因是采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，</p><p>在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到定义了一个 CopyOnWriteArrayList，在对这个集合遍历过程中，对集合元素做修改后，不会抛出异常，但同时也不会打印出增加的元素。</p><p>java.util.concurrent 包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。常见的的使用 fail-safe 方式遍历的容器有 ConcerrentHashMap 和CopyOnWriteArrayList 等。</p><hr><h3 id="谈谈你对-Seata-的理解"><a href="#谈谈你对-Seata-的理解" class="headerlink" title="谈谈你对 Seata 的理解"></a>谈谈你对 Seata 的理解</h3><hr><h3 id="Spring-Boot-的约定优于配置，你的理解是什么？"><a href="#Spring-Boot-的约定优于配置，你的理解是什么？" class="headerlink" title="Spring Boot 的约定优于配置，你的理解是什么？"></a>Spring Boot 的约定优于配置，你的理解是什么？</h3><ol><li><p>首先， 约定优于配置是一种软件设计的范式，它的核心思想是减少软件开发人员对于配置项的维护，从而让开发人员更加聚焦在业务逻辑上。</p></li><li><p>Spring Boot 就是约定优于配置这一理念下的产物，它类似于 Spring 框架下的一个脚手架，通过 Spring Boot，我们可以快速开发基于 Spring 生态下的应用程序。</p></li><li><p>基于传统的 Spring 框架开发 web 应用，我们需要做很多和业务开发无关并且只需要做一次的配置，比如</p><ul><li><p>管理 jar 包依赖</p></li><li><p>web.xml 维护</p></li><li><p>Dispatch-Servlet.xml 配置项维护</p></li><li><p>应用部署到 Web 容器</p></li><li><p>第三方组件集成到 Spring IOC 容器中的配置项维护</p></li></ul><p>而在 Spring Boot 中，我们不需要再去做这些繁琐的配置，Spring Boot 已经自动帮我</p><p>们完成了，这就是约定优于配置思想的体现。</p></li><li><p>Spring Boot 约定由于配置的体现有很多，比如</p><ul><li>Spring Boot Starter 启动依赖，它能帮我们管理所有 jar 包版本</li><li>如果当前应用依赖了 spring mvc 相关的 jar，那么 Spring Boot 会自动内置Tomcat 容器来运行 web 应用，我们不需要再去单独做应用部署。</li><li>Spring Boot 的自动装配机制的实现中，通过扫描约定路径下的spring.factories 文件来识别配置类，实现 Bean 的自动装配。</li><li>默认加载的配置文件 application.properties yml yaml等等。</li></ul><p>总的来说，约定优于配置是一个比较常见的软件设计思想，它的核心本质都是为了更高效以及更便捷的实现软件系统的开发和维护。</p></li></ol><hr><h2 id="kafka-的零拷贝原理"><a href="#kafka-的零拷贝原理" class="headerlink" title="kafka 的零拷贝原理"></a>kafka 的零拷贝原理</h2><hr><h2 id="innoDB-如何解决幻读"><a href="#innoDB-如何解决幻读" class="headerlink" title="innoDB 如何解决幻读"></a>innoDB 如何解决幻读</h2><hr><h2 id="lock-和-synchronized-区别"><a href="#lock-和-synchronized-区别" class="headerlink" title="lock 和 synchronized 区别"></a>lock 和 synchronized 区别</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Lock 和 Synchronized 都是 Java 中用来解决线程安全问题的工具。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合基础</title>
      <link href="/KendricW.github.io/2024/03/28/Java%E9%9B%86%E5%90%88%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/"/>
      <url>/KendricW.github.io/2024/03/28/Java%E9%9B%86%E5%90%88%EF%BC%88%E9%9D%A2%E8%AF%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h3 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h3><ul><li><code>List</code>(对付顺序的好帮手)：存储元素是有序的、可重复的</li><li><code>Set</code>(独一无二的性质)：存储的元素不可而重复的</li><li><code>Queue</code>(实现排队功能的叫号机)：按照特定的排队规则来确定先后顺序，存储的元素是有有序的、可重复的</li><li><code>Map</code>(用Key来搜索)：使用键值对存储<ul><li>key 无序的 不可重复的</li><li>value 无序的 可重复的</li><li>每个键最多映射到一个值</li></ul></li></ul><h2 id="Collection接口下面的集合"><a href="#Collection接口下面的集合" class="headerlink" title="Collection接口下面的集合"></a>Collection接口下面的集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><p><code>ArrayList</code>：</p><ul><li>底层实现：基于动态数组</li><li>查询速度快，通过索引访问元素的时间复杂度是O(1)，因为可以直接通过数组下标访问</li><li>插入和删除较慢（非首尾）当插入或删除元素时，为了维护数组的连续性，可能需要移动大量元素，时间复杂度通常是O(n)</li><li>可以容纳NULL</li><li>线程不安全，在多线程环境下若需保证线程安全，需要自行加锁或者使用<code>Collections.synchronizedList()</code> 方法包装。</li><li>动态扩容 当容量不足时，会自动扩大容量，一般按照容量的50%或更多进行扩容</li></ul></li><li><p><code>Vector</code>：</p><ul><li>底层实现：类似于ArrayList，也是基于数组</li><li>特点：<ul><li>功能上与ArrayList类似，但是它线程安全，内部方法都被同步了，因此多线程环境下操作不需要额外同步控制，但这也以为着并发访问时性能可能会比较低</li><li>同样具有动态扩容能力，但是在早期的Java版本中，默认的扩容策略也ArrayList不完全相同</li></ul></li></ul></li><li><p><code>LinkedList</code>：</p><ul><li>底层实现：基于双向链表</li><li>特点<ul><li>查询速度相对慢，由于链表结构，通过索引访问元素需要从头节点或者尾节点开始逐个遍历，时间复杂度为O(n)</li><li>插入和删除较快，在链表任何位置插入或者删除元素仅需改变相关节点的指针，时间复杂度为O(1)</li><li>可以容纳NULL</li><li>线程不安全</li><li>对于频繁的插入和删除操作以及需要高效的队列或双端队列功能时更为适用。</li></ul></li></ul></li></ul><h4 id="ArrayList和Array（数组）的区别"><a href="#ArrayList和Array（数组）的区别" class="headerlink" title="ArrayList和Array（数组）的区别"></a>ArrayList和Array（数组）的区别</h4><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><hr><h4 id="ArrayList可以添加null值吗？"><a href="#ArrayList可以添加null值吗？" class="headerlink" title="ArrayList可以添加null值吗？"></a>ArrayList可以添加null值吗？</h4><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过，不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; listOfStrings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">listOfStrings.add(<span class="literal">null</span>);</span><br><span class="line">listOfStrings.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">System.out.println(listOfStrings);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[null, java]</span><br></pre></td></tr></table></figure><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><p><code>HashSet</code></p><ul><li>底层实现：哈希表</li><li>无序且不重复</li><li>添加、删除以及查询元素的时间复杂度O(1)平均情况</li><li>不保证元素的迭代顺序，如果需要插入顺序或者自然顺序，请使用LinkedHashSet或TreeSet。</li></ul></li><li><p><code>LinkedHashSet</code>: </p><ul><li>底层实现：继承自HashSet</li><li>元素的迭代顺序是按照它们被插入到 set 中的顺序进行的</li></ul></li><li><p><code>TreeSet</code></p><ul><li>底层实现：基于红黑树（自平衡二叉查找树）实现</li><li>自然排序，总是处于排序状态。</li><li>查找、删除和插入操作的时间复杂度为O(log n)，n为集合中元素的数量。</li></ul></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul><li><code>PriorityQueue</code>: </li><li><code>DelayQueue</code>:</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试</title>
      <link href="/KendricW.github.io/2024/03/28/Mysql%E9%9D%A2%E8%AF%95/"/>
      <url>/KendricW.github.io/2024/03/28/Mysql%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql面试"><a href="#Mysql面试" class="headerlink" title="Mysql面试"></a>Mysql面试</h1><h2 id="数据库的三个范式"><a href="#数据库的三个范式" class="headerlink" title="数据库的三个范式"></a>数据库的三个范式</h2><ol><li>第一范式</li></ol><ul><li>每个表的字段都是不可再分的原子值，不允许出现复合值</li></ul><blockquote><p>一个员工表格中，“联系信息”列不应该包含多个电话号码，而应该把电话号码分成单独的列，如“家庭电话”、“办公电话”等。</p></blockquote><ol start="2"><li>第二范式</li></ol><ul><li>在满足第一范式的基础上，要求表中的所有非主键列必须完全依赖于整个主键，而不是主键的一部分（即不存在部分依赖）</li></ul><blockquote><p>假设有一个订单详情表，主键由订单ID和产品ID组成，不应该有仅仅依赖于产品ID的列（如产品价格），因为这违反了2NF，应将这部分数据移到另一个只依赖单一主键的产品表中。</p></blockquote><ol start="3"><li>第三范式</li></ol><ul><li>在满足第二范式的基础上，消除了非主键列对其他非主键列的传递依赖，即每个非主键列必须直接依赖于主键，而不能通过其他非主键列间接依赖于主键。</li></ul><blockquote><p>如果一个表格中有部门ID、经理ID和员工ID，经理ID本身是非主键但依赖于部门ID（经理属于某个部门），同时员工ID又依赖于经理ID（员工隶属于某个经理），这就形成了传递依赖，不符合3NF。应将经理与员工的关系分离到另一个表中。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试</title>
      <link href="/KendricW.github.io/2024/03/28/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/KendricW.github.io/2024/03/28/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis面试"><a href="#Redis面试" class="headerlink" title="Redis面试"></a>Redis面试</h1><h2 id="Redis是阻塞IO还是非阻塞IO"><a href="#Redis是阻塞IO还是非阻塞IO" class="headerlink" title="Redis是阻塞IO还是非阻塞IO"></a>Redis是阻塞IO还是非阻塞IO</h2><ul><li>redis使用的是非阻塞io结合io多路复用模型</li><li>Redis 服务端通过 I&#x2F;O 多路复用技术监听多个客户端连接，当有客户端发来请求时，虽然Redis主线程依然是顺序处理请求，但并不会因为某个命令在等待网络IO而阻塞其他命令的执行。</li><li>利用了非阻塞IO以及I&#x2F;O多路复用技术实现了高效的并发处理能力。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC基础概念</title>
      <link href="/KendricW.github.io/2024/03/27/JUC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/KendricW.github.io/2024/03/27/JUC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC基础概念"><a href="#JUC基础概念" class="headerlink" title="JUC基础概念"></a>JUC基础概念</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><ul><li><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</p></li><li><p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p></li><li><p>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h3><ul><li><p>一个进程之内可以分为一到多个线程。</p></li><li><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p></li><li><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</p></li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows</p><p>下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感</p><p>觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，</p><h3 id="引用-Rob-Pike-的一段描述："><a href="#引用-Rob-Pike-的一段描述：" class="headerlink" title="引用 Rob Pike 的一段描述："></a>引用 Rob Pike 的一段描述：</h3><p><strong>并发</strong>（concurrent）是同一时间应对（dealing with）多件事情的能力</p><p><strong>并行</strong>（parallel）是同一时间动手做（doing）多件事情的能力</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</p></li><li><p>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</p></li><li><p>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件查询思路</title>
      <link href="/KendricW.github.io/2024/03/27/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E6%80%9D%E8%B7%AF/"/>
      <url>/KendricW.github.io/2024/03/27/%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="条件查询思路"><a href="#条件查询思路" class="headerlink" title="条件查询思路"></a>条件查询思路</h1><h2 id="sql版本"><a href="#sql版本" class="headerlink" title="sql版本"></a>sql版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUserByTags</span><span class="params">(List&lt;String&gt; tagNameList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(tagNameList)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 拼接 and 关键词查询</span></span><br><span class="line">    <span class="keyword">for</span> (String tagName : tagNameList) &#123;</span><br><span class="line">        queryWrapper = queryWrapper.like(<span class="string">&quot;tags&quot;</span>, tagName);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> userList.stream().map(<span class="built_in">this</span>::getSafetyUser).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的遍历标签列表然后做条件的拼接</p><h2 id="基于内存版本"><a href="#基于内存版本" class="headerlink" title="基于内存版本"></a>基于内存版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUserByTags</span><span class="params">(List&lt;String&gt; tagNameList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(tagNameList)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="keyword">return</span> userList.stream().filter(user -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tagsStr</span> <span class="operator">=</span> user.getTags();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(tagsStr))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; tempTagNameSet = gson.fromJson(tagsStr,<span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Set&lt;String&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">        tempTagNameSet = Optional.ofNullable(tempTagNameSet).orElse(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (String tagName : tagNameList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tempTagNameSet.contains(tagName))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;).map(<span class="built_in">this</span>::getSafetyUser).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Gson 谷歌的序列化以及反序列化工具</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(tempTagNameSet).orElse(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;())</span><br></pre></td></tr></table></figure><p><strong>代码解读：</strong>如果<code>tempTagNameSet</code>为空，就给它赋上一个空的HashSet</p><p><strong>目的：</strong>减少程序的分支（if），降低程序的复杂度，提高可读性</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础</title>
      <link href="/KendricW.github.io/2024/03/21/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/KendricW.github.io/2024/03/21/Java%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试基础"><a href="#Java面试基础" class="headerlink" title="Java面试基础"></a>Java面试基础</h1><h2 id="Java语言的三大特性"><a href="#Java语言的三大特性" class="headerlink" title="Java语言的三大特性"></a>Java语言的三大特性</h2><ul><li><p>封装</p><ul><li>把属于同一类事物的共性（属性和方法）归到一个类中，以方便实用</li><li>专业分工，需要的时候再调用</li><li>隐藏信息，实现细节</li></ul></li><li><p>继承</p><ul><li>实现代码复用</li><li>遵行李氏代替原则</li><li>父类私有的属性和构造方法不能被继承</li><li>子类可以写自己特有的属性和方法，目的是实现功能的扩展</li></ul></li><li><p>多态</p><ul><li>以封装和继承为基础的</li><li>相同的事物，调用相同的方法，参数相同，但是表现的行为却不同</li><li>子类以父类的身份出现需要向上转型(upcast),其中向上转型是JVM自动实现的，是安全的</li><li>向下转型不安全，需要强制转换</li><li>子类以父类的身份出现时自己特有的属性和方法都不能使用</li></ul></li></ul><h2 id="JDK和JRE有什么区别？"><a href="#JDK和JRE有什么区别？" class="headerlink" title="JDK和JRE有什么区别？"></a>JDK和JRE有什么区别？</h2><ul><li>JDK：Java Development Kit的简称，Java开发工具包，提供开发环境和运行环境</li><li>JRE：Java Runtime Environment的简称，Java运行环境</li></ul><p>JDK包含JRE，还包括javac，调试和分析的工具</p><h2 id="如果main方法被声明为private会怎样？"><a href="#如果main方法被声明为private会怎样？" class="headerlink" title="如果main方法被声明为private会怎样？"></a>如果main方法被声明为private会怎样？</h2><ul><li>能正常编译，但是会提示不是public的</li><li>idea中会去掉可运行的按钮</li></ul><h2 id="与equals"><a href="#与equals" class="headerlink" title="&#x3D;&#x3D;与equals"></a>&#x3D;&#x3D;与equals</h2><ul><li>&#x3D;&#x3D;比较的是两个对象在内存中是不是同一个对象，就是说在内存里的存储位置一样</li><li>&#x3D;&#x3D;比较的是引用</li><li>equal比较的是内容</li></ul><h2 id="Object有哪些共用的方法"><a href="#Object有哪些共用的方法" class="headerlink" title="Object有哪些共用的方法"></a>Object有哪些共用的方法</h2><ul><li>clone 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用</li><li>equals 和&#x3D;&#x3D;一样，子类一般需要重写该方法</li><li>hashCode 哈希查找，重写了euqals方法一班都徐亚重写hashCode方法，在一些具有哈希功能的Collection中用到</li><li>getClass final方法，获得运行是类型</li><li>wait 使当前线程等待对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁，该方法一直等待，知道获得或者被中断，wait(long timeout)设定一个超时间隔，没有在规定时间内获得锁就返回</li><li>调用方法后当前线程进入睡眠状态<ul><li>其他线程调用了该对象的notify方法</li><li>其他线程调用了该对象的notifyAll方法</li><li>其他线程调用了interrupt中断该线程</li><li>时间间隔到了</li><li>线程可被调度，中断的话就抛异常</li></ul></li><li>notify 唤醒在该对象等待的某个线程</li><li>notifyAll 唤醒在该对象等待的所有线程</li><li>toString 一般子类重写</li></ul><h2 id="为什么Java中没有全局变量？"><a href="#为什么Java中没有全局变量？" class="headerlink" title="为什么Java中没有全局变量？"></a>为什么Java中没有全局变量？</h2><p>因为全局变量破坏了引用透明性原则，全局变量导致了命名空间的冲突</p><h2 id="while和dowhile有什么不同"><a href="#while和dowhile有什么不同" class="headerlink" title="while和dowhile有什么不同"></a>while和dowhile有什么不同</h2><p>dowhile至少执行一次</p><h2 id="char类型变量中能不能存储一个中文汉字？为什么？"><a href="#char类型变量中能不能存储一个中文汉字？为什么？" class="headerlink" title="char类型变量中能不能存储一个中文汉字？为什么？"></a>char类型变量中能不能存储一个中文汉字？为什么？</h2><p>可以</p><p>Java默认Unicode编码，占16位，char刚好就是16位</p><h2 id="float-f-3-4-是否正确-？"><a href="#float-f-3-4-是否正确-？" class="headerlink" title="float f &#x3D; 3.4;是否正确 ？"></a>float f &#x3D; 3.4;是否正确 ？</h2><p>不正确</p><p>3.4是双精度数double，向下转型会照成精度损失</p><p>正确写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">3.4</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">3.4F</span>;</span><br></pre></td></tr></table></figure><h2 id="与-的区别"><a href="#与-的区别" class="headerlink" title="&amp;与&amp;&amp;的区别"></a>&amp;与&amp;&amp;的区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a==b &amp; b==c</span><br></pre></td></tr></table></figure><p>即使a&#x3D;&#x3D;b为false，还会继续判断b是否等于c,不高效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a==b &amp;&amp; b==c</span><br></pre></td></tr></table></figure><p>a&#x3D;&#x3D;b 为false将不会继续判断，高效</p><ul><li>判断某对象的属性是否等于某值，必须使用&amp;&amp;，否则会出现空指针问题</li></ul><h2 id="Local类是什么？"><a href="#Local类是什么？" class="headerlink" title="Local类是什么？"></a>Local类是什么？</h2><p>根据语言环境来动态调整程序的输出</p><h2 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h2><p><strong>hashCode()</strong></p><ul><li><code>hashCode()</code> 是 <code>java.lang.Object</code> 类的一个方法，每个 Java 对象都继承了它。默认实现通常基于对象的内存地址计算出一个整数值，这个值被称为哈希码（hash code）。</li><li>哈希码的主要目的是为了高效地插入和查找对象。在诸如 <code>HashMap</code>、<code>HashSet</code> 或 <code>Hashtable</code> 这样的哈希表数据结构中，当我们将对象作为键放入其中时，会先计算对象的哈希码，将其转换为数组的索引。因此，哈希码用于快速定位对象可能所在的桶（bucket）。</li></ul><p><strong>equals()</strong></p><ul><li><code>equals()</code> 方法同样是从 <code>java.lang.Object</code> 类继承来的，它用于判断两个对象是否相等。默认行为是比较两个对象的引用是否指向同一个内存地址，即检查是否为同一个对象实例。</li><li>在实际应用中，我们通常会根据对象的实际内容重写 <code>equals()</code> 方法，以便当我们认为对象的内容相同时，它们就应该被视为相等的对象。</li></ul><p><strong>hashCode() 和 equals() 的关系</strong></p><ol><li><strong>一致性</strong>：如果两个对象通过 <code>equals()</code> 方法比较为相等（即 <code>a.equals(b)</code> 返回 <code>true</code>），那么它们的 <code>hashCode()</code> 方法必须返回相同的哈希码，即 <code>a.hashCode() == b.hashCode()</code>。</li><li><strong>非唯一性</strong>：两个不同的对象可能会计算出相同的哈希码，即 <code>hashCode()</code> 方法并不保证绝对唯一。但是，由于哈希表依赖于哈希码来分布元素，重复的哈希码会导致冲突并降低查找效率，所以良好的哈希函数应尽量减少冲突。</li><li><strong>不对称性</strong>：根据 <code>equals()</code> 和 <code>hashCode()</code> 的约定，如果两个对象的哈希码不相等 (<code>a.hashCode() != b.hashCode()</code>)，那么它们一定不相等 (<code>a.equals(b)</code> 会返回 <code>false</code>)。</li></ol><p>总结来说，在设计类时，如果类的实例会被用作哈希表的键，或者参与类似 <code>equals()</code> 的逻辑比较，那么就需要同时重写 <code>equals()</code> 和 <code>hashCode()</code> 方法，并确保它们的行为一致，这样才能保证哈希容器能够正确地工作。</p><ul><li>如果自定义对象作为Map的键的时候，就必须重写两种方法</li></ul><h2 id="深拷贝与浅拷贝的区别"><a href="#深拷贝与浅拷贝的区别" class="headerlink" title="深拷贝与浅拷贝的区别"></a>深拷贝与浅拷贝的区别</h2><h3 id="浅拷贝（Shallow-Copy）："><a href="#浅拷贝（Shallow-Copy）：" class="headerlink" title="浅拷贝（Shallow Copy）："></a>浅拷贝（Shallow Copy）：</h3><ol><li>当一个对象执行浅拷贝时，系统会创建一个新的对象，新对象的非引用类型字段（如基本类型int, double, char等）将复制源对象对应字段的值。</li><li><strong>对于引用类型字段（如对象引用或数组引用）</strong>，浅拷贝只会复制这些引用的值，也就是说，新对象和原对象中的引用类型字段将指向相同的内存地址。</li><li>结果是，如果浅拷贝后修改了引用类型字段所指向的对象的内部状态，那么这种变化会反映在原对象和新拷贝的对象上，因为它们实际上共享了这部分内存。</li></ol><h3 id="深拷贝（Deep-Copy）："><a href="#深拷贝（Deep-Copy）：" class="headerlink" title="深拷贝（Deep Copy）："></a>深拷贝（Deep Copy）：</h3><ol><li>深拷贝同样是创建一个新的对象，非引用类型字段也同样复制。</li><li>关键在于，对于引用类型字段，深拷贝不仅仅复制引用，还会递归地复制引用对象本身的所有内容（包括其内部的引用类型字段）。换句话说，如果对象内嵌套有其他对象，深拷贝会为嵌套对象创建全新的副本，而不是共享引用。</li><li>因此，深拷贝之后，即使修改新对象中引用类型字段指向的新对象的状态，也不会影响原对象及其相应引用的任何内容，二者之间是完全独立的实体。</li></ol><p>简而言之，浅拷贝仅复制对象的第一层引用，而深拷贝则是彻底复制整个对象树，确保所有层级的对象都被独立复制出来，形成与原对象在内存中完全隔离的副本。</p><p>在Java中实现深拷贝通常需要手动编写代码，特别是当对象结构复杂且存在多层嵌套引用时，可能需要用到序列化（比如使用<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>）或克隆接口（如<code>Cloneable</code>接口配合<code>clone()</code>方法，但需要注意<code>clone()</code>方法默认也是浅拷贝，需要重写以实现深拷贝功能）。另外，也可以通过构造函数或拷贝构造器等方式逐个字段进行深拷贝操作。</p><h2 id="Java中操作字符串都有那些类，区别？"><a href="#Java中操作字符串都有那些类，区别？" class="headerlink" title="Java中操作字符串都有那些类，区别？"></a>Java中操作字符串都有那些类，区别？</h2><ol><li><strong>String 类</strong><ul><li>String 类是Java中表示不可变字符序列的核心类。</li><li>特点：<ul><li>不可变性：一旦创建了String对象，它的值就不可更改。这意味着对String对象的任何修改（如拼接、替换、截取等）都不会改变原有对象的内容，而是会创建一个新的String对象。</li><li>字符串池：Java通过String Pool机制优化了大量相同的字符串实例，使得在内存中只有一份相同内容的字符串对象。</li><li>安全性：由于其不可变性，String类天然就是线程安全的。</li></ul></li></ul></li><li><strong>StringBuilder 类</strong>（单线程）<ul><li>StringBuilder 类是用来处理可变字符序列的，它是非线程安全的。</li><li>特点：<ul><li>可变性：StringBuilder对象允许在其内部缓冲区直接修改字符序列，无需创建新的对象。</li><li>效率：相比于String类，StringBuilder在进行大量的字符串操作（尤其是拼接操作）时，由于减少了不必要的对象创建，因此在性能上有显著优势。</li><li>线程安全性：StringBuilder在单线程环境下使用时，由于省去了同步锁，所以在修改字符串时速度更快。</li></ul></li></ul></li><li><strong>StringBuffer 类</strong>（多线程）<ul><li>StringBuffer 类也表示可变字符序列，与StringBuilder非常相似。</li><li>特点：<ul><li>同步性：StringBuffer类的所有方法都是同步的，意味着它在多线程环境中的字符串操作是线程安全的。</li><li>性能：相较于StringBuilder，由于StringBuffer增加了同步控制，所以在多线程环境下虽然保证了线程安全，但也牺牲了一定的性能。</li></ul></li></ul></li></ol><p>在实际开发中，选择哪种类取决于具体的应用场景：</p><ul><li>如果字符串内容在创建后不需要改变，或者用于多处读取但很少修改的情况，应优先选用String类。</li><li>如果需要频繁修改字符串内容，并且程序运行在单线程环境下，推荐使用StringBuilder，因为它提供了更高的性能。</li><li>当字符串操作发生在多线程环境下，为了防止数据竞争问题，应当使用StringBuffer以确保线程安全。</li></ul><h2 id="String-str-“a”-String-str-new-String-“a”-；一样吗？"><a href="#String-str-“a”-String-str-new-String-“a”-；一样吗？" class="headerlink" title="String str &#x3D; “a” ; String str &#x3D; new String(“a”)；一样吗？"></a>String str &#x3D; “a” ; String str &#x3D; new String(“a”)；一样吗？</h2><p>String str &#x3D; “a” -&gt; 常量池</p><p>String str &#x3D; new String(“a”) -&gt; 堆内存</p><h2 id="抽象类能使用final修饰吗？"><a href="#抽象类能使用final修饰吗？" class="headerlink" title="抽象类能使用final修饰吗？"></a>抽象类能使用final修饰吗？</h2><p>不能</p><p>抽象类就是让其他类来继承的</p><h2 id="static关键字五连问"><a href="#static关键字五连问" class="headerlink" title="static关键字五连问"></a>static关键字五连问</h2><h3 id="抽象的方法是否可以是静态的"><a href="#抽象的方法是否可以是静态的" class="headerlink" title="抽象的方法是否可以是静态的"></a>抽象的方法是否可以是静态的</h3><p>抽象的方法是要被重写的，静态方法无法重写</p><h3 id="是否可以从一个静态的方法内部发出非静态方法的调用"><a href="#是否可以从一个静态的方法内部发出非静态方法的调用" class="headerlink" title="是否可以从一个静态的方法内部发出非静态方法的调用"></a>是否可以从一个静态的方法内部发出非静态方法的调用</h3><p>不可以，静态方法只能访问静态成员，非静态方法的调用要先创建对象</p><h3 id="static是否可以修饰局部变量"><a href="#static是否可以修饰局部变量" class="headerlink" title="static是否可以修饰局部变量"></a>static是否可以修饰局部变量</h3><p>不允许</p><h3 id="内部类与静态内部类的区别"><a href="#内部类与静态内部类的区别" class="headerlink" title="内部类与静态内部类的区别"></a>内部类与静态内部类的区别</h3><p>内部类（Non-static Inner Class）与静态内部类（Static Nested Class）在Java中有着显著的区别，以下是主要的不同点：</p><ol><li><p><strong>依赖性</strong>：</p><ul><li><strong>非静态内部类（普通内部类）</strong>：此类需要依赖外部类的实例才能创建对象，即非静态内部类的实例总是与其外部类实例相关联。创建非静态内部类对象时，必须先有一个外部类对象的存在。</li><li><strong>静态内部类（静态嵌套类）</strong>：不需要依赖外部类的实例，可以直接创建对象，就像普通的顶级类一样。</li></ul></li><li><p><strong>访问外部类成员</strong>：</p><ul><li><strong>非静态内部类</strong>：可以直接访问外部类的所有成员（包括静态和非静态的变量和方法），因为它隐式持有了对外部类实例的引用。</li><li><strong>静态内部类</strong>：只能访问外部类的静态成员（静态变量和静态方法），不能直接访问外部类的非静态成员，除非通过传入外部类实例的方式访问。</li></ul></li><li><p><strong>成员变量和方法</strong>：</p><ul><li><strong>非静态内部类</strong>：可以有非静态变量和方法。</li><li><strong>静态内部类</strong>：既可以有静态变量和静态方法，也可以有非静态变量和方法。</li></ul></li><li><p><strong>生命周期</strong>：</p><ul><li><strong>非静态内部类</strong>：其生命周期与外部类的实例绑定在一起。</li><li><strong>静态内部类</strong>：生命周期不受外部类实例的影响，可以独立存在。</li></ul></li><li><p><strong>实例化方式</strong>：</p><ul><li><strong>非静态内部类</strong>：实例化时需先创建外部类实例，然后通过外部类实例创建内部类实例。</li></ul><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1<span class="type">OuterClass</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">2OuterClass.<span class="type">InnerClass</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>静态内部类</strong>：实例化时可以直接通过类名创建，无需外部类实例。</li></ul><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1OuterClass.<span class="type">StaticInnerClass</span> <span class="variable">staticInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>.StaticInnerClass();</span><br></pre></td></tr></table></figure></li><li><p><strong>访问权限</strong>：</p><ul><li><strong>非静态内部类</strong>：访问权限除了public、protected、包访问权限之外，还可以是private。</li><li><strong>静态内部类</strong>：访问权限与非静态内部类相同，但通常情况下静态内部类由于不依赖外部类实例，更容易设计为public访问权限。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li><strong>非静态内部类</strong>：常用于表示与外部类有紧密联系的概念，例如事件监听器、回调函数、实现了某个接口的对象等，它能够方便地访问外部类的私有信息。</li><li><strong>静态内部类</strong>：更多用于逻辑上的组织和封装，它可以访问外部类的静态资源，但不与特定的外部类实例绑定，因此更适合于工具类、辅助类的设计，或者是在外部类中定义一些相关的类，增强代码的模块化和内聚性。</li></ul></li></ol><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><p>重载（Overloading）与重写（Overriding）是面向对象编程中的两个重要概念，它们在Java等支持多态的编程语言中有明确的区别：</p><p><strong>重载 (Overloading)：</strong></p><ul><li><strong>定义</strong>：在同一类中，方法名相同，但参数列表不同（参数的数量、类型或顺序不同）。返回类型可以相同也可以不同，但不是区分重载方法的依据。</li><li><strong>目的</strong>：增加代码的灵活性和可读性，允许使用相同的方法名称完成多种功能，只需根据传入参数的不同就能决定调用哪个方法。</li><li><strong>作用范围</strong>：局限于单个类中。</li><li><strong>编译时期决策</strong>：编译器根据传入的参数类型和数量决定调用哪个重载的方法。</li></ul><p><strong>重写 (Overriding)：</strong></p><ul><li><strong>定义</strong>：在继承关系中，子类重新定义了父类中已经存在的方法，而且方法名、参数列表、返回类型（Java要求返回类型为父类方法返回类型的子类型或相同类型）、以及抛出的异常（子类重写的方法抛出的异常不能超过父类被重写方法抛出的异常）都要与父类保持一致。</li><li><strong>目的</strong>：提供多态性，允许子类根据需要改变或扩展父类的行为。</li><li><strong>作用范围</strong>：涉及到父类与子类之间的关系。</li><li><strong>运行时期决策</strong>：在多态的情况下，调用方法的真正主体在运行时确定，即动态绑定，根据对象的实际类型调用相应的方法实现。</li></ul><p>总结一下，重载是基于同一作用域下方法签名的不同来实现同一方法名的多种功能；而重写则是在继承层次结构中，子类对父类已有的方法提供新的实现，从而改变或扩展其行为，体现的是面向对象的多态特性。</p><h2 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h2><p>Java中提供了四种类型的引用，分别是强引用、软引用、弱引用和虚引用，它们对对象的生命周期控制和垃圾回收过程有不同的影响：</p><ol><li><p><strong>强引用 (Strong Reference)</strong></p><ul><li><p>最常见的引用类型，当一个对象具有强引用时，垃圾回收器绝不会回收它，即使内存不足，系统也会抛出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutOfMemoryError</span><br></pre></td></tr></table></figure><p>错误，也不会回收仍然具有强引用的对象来释放内存。只要强引用还在，对象就会一直有效，无法被回收。例如：</p><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 创建了一个强引用</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>软引用 (Soft Reference)</strong></p><ul><li><p>当内存空间不足时，系统将会试图回收那些只具有软引用的对象。软引用非常适合用来构建内存敏感的数据结构，如缓存。一旦 JVM 内存不足，会优先清理软引用指向的对象。Java 提供</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ref.SoftReference</span><br></pre></td></tr></table></figure><p>类来实现软引用。</p><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>弱引用 (Weak Reference)</strong></p><ul><li><p>弱引用对象拥有更短暂的生命周期。只要垃圾回收器检测到对象只具有弱引用，不论内存是否足够，都会回收该对象。弱引用经常用于实现那些生命周期较短或者可以根据需要自动丢弃的对象。Java 使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ref.WeakReference</span><br></pre></td></tr></table></figure><p>类来实现弱引用。</p><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>虚引用 (Phantom Reference)</strong></p><ul><li><p>虚引用又称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获得对象实例。当一个对象仅持有虚引用时，随时可能被垃圾回收器回收。虚引用的主要目的是在对象被回收之前，能够收到一个系统通知。虚引用必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。Java 使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.ref.PhantomReference</span><br></pre></td></tr></table></figure><p>类来实现虚引用，并搭配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ReferenceQueue</span><br></pre></td></tr></table></figure><p>使用。</p><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">2PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), queue);</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>每种引用类型都是通过 <code>java.lang.ref</code> 包下的类实现的，它们让开发者可以更加精细地控制对象的生命周期，有助于提高内存管理效率，特别是在内存受限的环境中。</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>在Java中，为了实现对象的序列化和反序列化，需要让对象所属的类实现 <code>java.io.Serializable</code> 接口。这个接口是一个标记接口，即它自身没有定义任何方法，仅仅是用来标识一个类是可以被序列化的。</p><p>如果你希望一个类的实例能够被转化为字节流存储或通过网络进行传输，就需要让该类实现 <code>Serializable</code> 接口：</p><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1public <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="number">2</span>    <span class="comment">// 类的属性和方法...</span></span><br><span class="line"><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>不过，如果某些类的属性不应该被序列化，可以通过以下几种方式避免序列化：</p><ol><li>使用 <code>transient</code> 关键字修饰字段：被 <code>transient</code> 关键字修饰的字段不会被包含在序列化的过程中。</li></ol><p>Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">1public <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">private</span> <span class="keyword">transient</span> SomeType nonSerializedField;</span><br><span class="line"><span class="number">3</span>    <span class="comment">// 其他需要序列化的字段...</span></span><br><span class="line"><span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>serialVersionUID</code> 控制版本兼容性：如果不希望类的某个版本被旧版本反序列化，可以显式声明 <code>serialVersionUID</code> 并更改其值。</li><li>实现 <code>writeObject(ObjectOutputStream out)</code> 和 <code>readObject(ObjectInputStream in)</code> 方法：可以自定义序列化和反序列化过程，这样就可以在序列化时忽略某些字段或采取特殊策略。</li><li>使用 <code>Externalizable</code> 接口替代 <code>Serializable</code> 接口：<code>Externalizable</code> 接口要求实现 <code>writeExternal(ObjectOutput out)</code> 和 <code>readExternal(ObjectInput in)</code> 两个方法，这样可以完全控制对象的序列化和反序列化过程。</li></ol><p>若不想让整个类成为可序列化的，只需不实现 <code>Serializable</code> 接口即可。但请注意，如果一个类的父类实现了 <code>Serializable</code> 接口，则子类默认也是可序列化的，除非子类显式声明它不希望序列化（这通常是通过不实现 <code>Serializable</code> 并移除父类中不需要序列化的字段来间接实现的）。在某些情况下，如果确实需要阻止序列化，可以添加一个受保护的无参构造函数，但这不是一个标准做法，因为可能会影响到其他依赖于默认构造函数的框架或库。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/KendricW.github.io/2024/03/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/KendricW.github.io/2024/03/20/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="三种类加载器"><a href="#三种类加载器" class="headerlink" title="三种类加载器"></a>三种类加载器</h2><ol><li><strong>引导类加载器（Bootstrap ClassLoader）</strong>：<ul><li>这是最顶层的类加载器，也称为启动类加载器。它是用C++编写的，直接嵌入到JVM内部。</li><li>负责加载JVM基础核心类库（rt.jar），这些类库位于<code>JAVA_HOME/lib</code>目录下。</li><li>由于引导类加载器是JVM的一部分，它不继承自<code>java.lang.ClassLoader</code>类。</li></ul></li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：<ul><li>位于引导类加载器之下，负责加载<code>JAVA_HOME/lib/ext</code>目录中或者由系统属性<code>java.ext.dirs</code>指定位置中的类库。</li><li>这些类库通常包含Java的扩展API，例如加密、SSL等。</li><li>扩展类加载器是<code>java.lang.ClassLoader</code>的子类。</li></ul></li><li><strong>系统类加载器（System ClassLoader）</strong>，也称为应用类加载器（Application ClassLoader）：<ul><li>负责按照Java应用的类路径（CLASSPATH）来加载Java类。</li><li>Maven引入的依赖</li><li>它是<code>java.lang.ClassLoader</code>的一个实例，派生于<code>sun.misc.Launcher$AppClassLoader</code>。</li><li>应用程序中自定义的类加载器通常继承自这个类加载器。</li></ul></li></ol><h2 id="用户扩展基础jar包"><a href="#用户扩展基础jar包" class="headerlink" title="用户扩展基础jar包"></a>用户扩展基础jar包</h2><p>如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：</p><ul><li><strong>放入jre&#x2F;lib下进行扩展</strong>。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。</li><li><strong>使用参数进行扩展。</strong>推荐，使用-Xbootclasspath&#x2F;a:jar包目录&#x2F;jar包名 进行扩展，参数中的&#x2F;a代表新增。</li><li></li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><img src="https://big-event-wzx.oss-cn-beijing.aliyuncs.com/output.png" title="可选的标题"></p><p>双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，</p><p>再由顶向下进行加载。</p><p>每个类加载器都有一个父类加载器。启动类加载器没有父类加载器</p><p>在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。 </p><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>比如com.itheima.my.A假设在启动类加载器的加载目录中，而应用程序类加载器接到了加载类的任务。</p><p>1、应用程序类加载器首先判断自己加载过没有，没有加载过就交给父类加载器 - 扩展类加载器。</p><p>2、扩展类加载器也没加载过，交给他的父类加载器 - 启动类加载器。</p><p>3、启动类加载器发现已经加载过，直接返回。</p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>B类在扩展类加载器加载路径中，同样应用程序类加载器接到了加载任务，按照案例1中的方式一层一层向上查找，发现都没有加载过。那么启动类加载器会首先尝试加载。它发现这类不在它的加载目录中，向下传递给扩展类加载器。</p><p>扩展类加载器发现这个类在它加载路径中，加载成功并返回。</p><p>如果第二次再接收到加载任务，同样地向上查找。扩展类加载器发现已经加载过，就可以返回了。</p><h3 id="三个面试题"><a href="#三个面试题" class="headerlink" title="三个面试题"></a>三个面试题</h3><p>1、如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？</p><p>启动类加载器加载，根据双亲委派机制，它的优先级是最高的</p><p>2、String类能覆盖吗，在自己的项目中去创建一个java.lang.String类，会被加载吗？</p><p>不能，会返回启动类加载器加载在rt.jar包中的String类。</p><p>3、<strong>类的双亲委派机制是什么？</strong></p><ul><li>当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。</li><li>应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。</li><li>双亲委派机制的好处有两点：第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。</li></ul><h3 id="双亲委派机制的作用"><a href="#双亲委派机制的作用" class="headerlink" title="双亲委派机制的作用"></a>双亲委派机制的作用</h3><p>1.保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。</p><p>2.避免重复加载。双亲委派机制可以避免同一个类被多次加载。</p><h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><p>打破双亲委派机制历史上有三种方式，但本质上只有第一种算是真正的打破了双亲委派机制：</p><ul><li>自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离。</li><li>线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。</li><li>Osgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h4><p>一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。</p><p>Tomcat使用了自定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。</p><p>那么自定义加载器是如何能做到的呢？首先我们需要先了解，双亲委派机制的代码到底在哪里，接下来只需要把这段代码消除即可。</p><p>ClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于loadClass方法中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)</span><br><span class="line">类加载的入口，提供了双亲委派机制。内部会调用findClass   重要</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)</span><br><span class="line">由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span><br><span class="line">执行类生命周期中的连接阶段</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader.broken;<span class="comment">//package com.itheima.jvm.chapter02.classloader.broken;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打破双亲委派机制 - 自定义类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BreakClassLoader1</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basePath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">FILE_EXT</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置加载目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasePath</span><span class="params">(String basePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.basePath = basePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用commons io 从指定目录下加载文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name)  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tempName</span> <span class="operator">=</span> name.replaceAll(<span class="string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(basePath + tempName + FILE_EXT);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> IOUtils.toByteArray(fis);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IOUtils.closeQuietly(fis);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;自定义类加载器加载失败，错误原因：&quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写loadClass方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//如果是java包下，还是走双亲委派机制</span></span><br><span class="line">        <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;java.&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从磁盘中指定目录下加载</span></span><br><span class="line">        <span class="type">byte</span>[] data = loadClassData(name);</span><br><span class="line">        <span class="comment">//调用虚拟机底层方法，方法区和堆区创建对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//第一个自定义类加载器对象</span></span><br><span class="line">        <span class="type">BreakClassLoader1</span> <span class="variable">classLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BreakClassLoader1</span>();</span><br><span class="line">        classLoader1.setBasePath(<span class="string">&quot;D:\\lib\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line">         <span class="comment">//第二个自定义类加载器对象</span></span><br><span class="line">        <span class="type">BreakClassLoader1</span> <span class="variable">classLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BreakClassLoader1</span>();</span><br><span class="line">        classLoader2.setBasePath(<span class="string">&quot;D:\\lib\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader1);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认情况下，自定义类加载器的父类是引用程序类加载器</strong></p><h5 id="两个自定义类加载器加载相同限定名的类，不会冲突吗？"><a href="#两个自定义类加载器加载相同限定名的类，不会冲突吗？" class="headerlink" title="两个自定义类加载器加载相同限定名的类，不会冲突吗？"></a>两个自定义类加载器加载相同限定名的类，不会冲突吗？</h5><p>不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。</p><p>在Arthas中使用sc –d 类名的方式查看具体的情况。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">       <span class="comment">//第一个自定义类加载器对象</span></span><br><span class="line">       <span class="type">BreakClassLoader1</span> <span class="variable">classLoader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BreakClassLoader1</span>();</span><br><span class="line">       classLoader1.setBasePath(<span class="string">&quot;D:\\lib\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Class&lt;?&gt; clazz1 = classLoader1.loadClass(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个自定义类加载器对象</span></span><br><span class="line">       <span class="type">BreakClassLoader1</span> <span class="variable">classLoader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BreakClassLoader1</span>();</span><br><span class="line">       classLoader2.setBasePath(<span class="string">&quot;D:\\lib\\&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Class&lt;?&gt; clazz2 = classLoader2.loadClass(<span class="string">&quot;com.itheima.my.A&quot;</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(clazz1 == clazz2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印的应该是false，因为两个类加载器不同，尽管加载的是同一个类名，最终Class对象也不是相同的。</p><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><h3 id="Osgi框架的类加载器"><a href="#Osgi框架的类加载器" class="headerlink" title="Osgi框架的类加载器"></a>Osgi框架的类加载器</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的生命周期</title>
      <link href="/KendricW.github.io/2024/03/20/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/KendricW.github.io/2024/03/20/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类的声明周期描述了一个类“加载，使用，卸载”的整个过程，整体可以分为：</p><ul><li>加载</li><li>连接 （验证，准备，解析）三个子阶段</li><li>初始化</li><li>使用</li><li>卸载</li></ul><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>类加载器根据类的全限定名通过不同渠道以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。</p><ul><li>本地硬盘获取文件</li><li>运行时通过动态代理生成，例如Spring框架</li><li>Applet技术通过网络取字节码文件</li></ul><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>加载完类以后， Java虚拟机会将字节码中的信息保存在方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里面还包括实现特定功能比如多态的信息。</p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据（ jdk8及之后）</p><h2 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h2><p>三个子阶段：</p><ul><li>验证 验证内容是否满足《Java虚拟机规范》</li><li>准备 给静态变量赋初值</li><li>解析 将常量池中的符号引用替换成指向内存的直接引用</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>主要目的：检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段不需要程序员参与</p><p>主要包含下面四部分：</p><ul><li>文件格式验证，ca fe魔数的校验，主次版本号</li><li>元信息验证，例如类必须有父类（super不能为空）</li><li>验证城西执行指令的语意，比如方法内的指令执行中跳转到不正确的位置</li><li>符号引用验证，例如是否访问了其他类中private的方法等</li></ul><p>主版本号的验证：</p><p>编译文件的主版本号不能高于运行环境主版本号</p><p>如果主版本号相等，副版本号也不能超过。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>初始值</strong></th></tr></thead><tbody><tr><td><strong>int</strong></td><td><strong>0</strong></td></tr><tr><td><strong>long</strong></td><td><strong>0L</strong></td></tr><tr><td><strong>short</strong></td><td><strong>0</strong></td></tr><tr><td><strong>char</strong></td><td><strong>‘\u0000’</strong></td></tr><tr><td><strong>byte</strong></td><td><strong>0</strong></td></tr><tr><td><strong>boolean</strong></td><td><strong>false</strong></td></tr><tr><td><strong>double</strong></td><td><strong>0.0</strong></td></tr><tr><td><strong>引用****数据类型</strong></td><td><strong>null</strong></td></tr></tbody></table><p>如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在准备阶段会为value分配内存并赋初值为0，在初始化阶段才会将值修改为1。</p><p>final修饰的变量，在准备阶段直接赋值。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段主要是将常量池中的符号引用替换为直接引用</p><p>符号引用就是在字节码文件中使用编号来访问常量池的内容</p><p>直接引用不再使用编号，而是使用内存中地址进行访问具体的数据</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>初始化阶段会执行字节码文件中的clinit（class init类的初始化）方法的字节码指令，包含了静态代码快中的代码，并为静态变量赋值</p><p>如下代码编译成字节码文件之后，会生成三个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        value = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[0]  init</p><p>[1] main</p><p>[2]  clinit</p><ul><li>init方法，会在对象初始化时执行</li><li>main方法，主方法</li><li>clinit方法，类的初始化阶段执行</li></ul><h2 id="导致类的初始化："><a href="#导致类的初始化：" class="headerlink" title="导致类的初始化："></a>导致类的初始化：</h2><p>1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。</p><p>2.调用Class.forName(String className)。</p><p>3.new一个该类的对象时。</p><p>4.执行Main方法的当前类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果应该是DACBCB</p><h4 id="clinit不会执行的几种情况"><a href="#clinit不会执行的几种情况" class="headerlink" title="clinit不会执行的几种情况"></a>clinit不会执行的几种情况</h4><p>如下几种情况是不会进行初始化指令执行的：</p><p>1.无静态代码块且无静态变量赋值语句。</p><p>2.有静态变量的声明，但是没有赋值语句。</p><p>3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>如下代码的输出结果是什么？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B02</span>();</span><br><span class="line">        System.out.println(B02.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A02</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B02</span> <span class="keyword">extends</span> <span class="title class_">A02</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析步骤：</p><p>1、调用new创建对象，需要初始化B02，优先初始化父类。</p><p>2、执行A02的初始化代码，将a赋值为1。</p><p>3、B02初始化，将a赋值为2。</p><h5 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h5><p>将<code>new B02();</code>注释掉会怎么样？</p><p>分析步骤：</p><p>1、访问父类的静态变量，只初始化父类。</p><p>2、执行A02的初始化代码，将a赋值为1。</p><h4 id="补充练习题"><a href="#补充练习题" class="headerlink" title="补充练习题"></a>补充练习题</h4><p>分析如下代码执行结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test2_A[] arr = <span class="keyword">new</span> <span class="title class_">Test2_A</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2_A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test2 A的静态代码块运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的创建不会导致数组中元素的类进行初始化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test4_A.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test4_A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test3 A的静态代码块运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码文件</title>
      <link href="/KendricW.github.io/2024/03/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"/>
      <url>/KendricW.github.io/2024/03/19/%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码文件详解"><a href="#字节码文件详解" class="headerlink" title="字节码文件详解"></a>字节码文件详解</h1><h2 id="Java虚拟机的组成"><a href="#Java虚拟机的组成" class="headerlink" title="Java虚拟机的组成"></a>Java虚拟机的组成</h2><p>Java虚拟机主要分为以下几个组成部分：</p><ul><li>类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。</li><li>运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。</li><li>执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。</li><li>本地接口：调用本地使用C&#x2F;C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示。</li></ul><h2 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h2><h3 id="以正确的姿势打开文件"><a href="#以正确的姿势打开文件" class="headerlink" title="以正确的姿势打开文件"></a>以正确的姿势打开文件</h3><p>无法解读出文件里包含的内容，推荐使用 jclasslib工具查看字节码文件。</p><p>Github地址： <a href="https://github.com/ingokegel/jclasslib">https://github.com/ingokegel/jclasslib</a></p><h3 id="字节码文件的组成-1"><a href="#字节码文件的组成-1" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h3><p>字节码文件总共可以分为以下几个部分：</p><ul><li><strong>基础信息</strong>：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息</li><li><strong>常量池</strong>： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用</li><li><strong>字段：</strong> 当前类或接口声明的字段信息</li><li><strong>方法：</strong> 当前类或接口声明的方法信息，核心内容为方法的字节码指令</li><li><strong>属性：</strong> 类的属性，比如源码的文件名、内部类的列表等</li></ul><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p><strong>Magic魔数</strong></p><p>每个Java字节码文件的前四个字节是固定的，用16进制表示就是0xcafebabe。文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。</p><p>Java字节码文件中，将文件头称为magic魔数。Java虚拟机会校验字节码文件的前四个字节是不是0xcafebabe，如果不是，该字节码文件就无法正常使用，Java虚拟机会抛出对应的错误。</p><p><strong>主副版本号</strong></p><p>1.2之后大版本号计算方法就是 : <em><strong>主版本号 – 44，比如主版本号52就是JDK8。</strong></em></p><p>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。如果使用较低版本的JDK去运行较高版本JDK的字节码文件，无法使用会显示错误</p><p>有两种方案：</p><p>1.<strong>升级JDK版本</strong>，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。</p><p>2.<strong>将第三方依赖的版本号降低或者更换依赖</strong>，以满足JDK版本的要求。建议使用这种方案</p><p><strong>其他基础信息</strong></p><p>其他基础信息包括访问标识、类和接口索引</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。</p><p>比如在代码中，编写了两个相同的字符串“我爱北京天安门”，字节码文件甚至将来在内存中使用时其实只需要保存一份，此时就可以将这个字符串以及字符串里边包含的字面量，放入常量池中以达到节省空间的作用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;我爱北京天安门&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;我爱北京天安门&quot;</span>;</span><br></pre></td></tr></table></figure><p>常量池中的数据都有一个编号，编号从1开始。比如“我爱北京天安门”这个字符串，在常量池中的编号就是7。在字段或者字节码指令中通过编号7可以快速的找到这个字符串。</p><p>字节码指令中通过编号引用到常量池的过程称之为符号引用。</p><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>字段中存放的是当前类或接口声明的字段信息。</p><p>如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public&#x2F;private static final等）。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>字节码中的方法区域是存放<strong>字节码****指令</strong>的核心位置，字节码指令的内容存放在方法的Code属性中。</p><p>要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。</p><p><strong>操作数栈</strong>是用来存放临时数据的内容，是一个栈式的结构，先进后出。</p><p><strong>局部变量****表</strong>是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识JVM</title>
      <link href="/KendricW.github.io/2024/03/19/%E5%88%9D%E8%AF%86JVM/"/>
      <url>/KendricW.github.io/2024/03/19/%E5%88%9D%E8%AF%86JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="初识JVM-基础"><a href="#初识JVM-基础" class="headerlink" title="初识JVM-基础"></a>初识JVM-基础</h1><p><code>JVM</code>全称：JAVA Virtual Machine，中文名Java虚拟机，是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p><h2 id="Java源代码执行流程如下："><a href="#Java源代码执行流程如下：" class="headerlink" title="Java源代码执行流程如下："></a>Java源代码执行流程如下：</h2><p>分为三个步骤：<br>1.编写Java源代码文件。<br>2.使用Java编译器（javac命令）将源代码编译成Java字节码文件。<br>3.使用Java虚拟机加载并运行Java字节码文件，此时会启动一个新的进程。</p><h2 id="Java的三大核心功能"><a href="#Java的三大核心功能" class="headerlink" title="Java的三大核心功能"></a>Java的三大核心功能</h2><ul><li>内存管理</li><li>解释执行虚拟机指令</li><li>及时编译</li></ul><h3 id="解释和运行"><a href="#解释和运行" class="headerlink" title="解释和运行"></a>解释和运行</h3><p>对字节码文件中的指令，实时的解释成机器码，让计算机执行。</p><p>字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>自动为对象、方法等分配内存</li><li>自动的垃圾回收机制，回收不再使用的对象</li></ul><p>Java虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C&#x2F;C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。</p><h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><p>热点代码进行优化，提升执行效率。</p><p><strong>提升Java最核心的手段</strong></p><h2 id="Java性能低的主要原因和跨平台特性"><a href="#Java性能低的主要原因和跨平台特性" class="headerlink" title="Java性能低的主要原因和跨平台特性"></a>Java性能低的主要原因和跨平台特性</h2><p>Java语言如果不做任何的优化，性能其实是不如C和C++语言的。主要原因是：</p><p>在程序运行过程中，Java虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。</p><p>C和C++语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。</p><p>Java为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在windows或者linux上运行。可以使用同一份字节码指令，交给windows和linux上的Java虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了Write Once，Run Anywhere 编写一次，到处运行的目标。</p><p>但是C&#x2F;C++语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。</p><p>再回到即时编译，在JDK1.1的版本中就推出了即时编译去优化对应的性能。</p><p>虚拟机在运行过程中如果发现某一个方法甚至是循环是热点代码（被非常高频调用），即时编译器会优化这段代码并将优化后的机器码保存在内存中，如果第二次再去执行这段代码。Java虚拟机会将机器码从内存中取出来直接进行调用。这样节省了一次解释的步骤，同时执行的是优化后的代码，效率较高。</p><p>Java通过即时编译器获得了接近C&#x2F;C++语言的性能，在某些特定的场景下甚至可以实现超越。</p><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><table><thead><tr><th>名称</th><th>作者</th><th>支持版本</th><th>社区活跃度（github star）</th><th>特性</th><th>适用场景</th></tr></thead><tbody><tr><td>HotSpot (Oracle JDK版)</td><td>Oracle</td><td>所有版本</td><td>高(闭源)</td><td>使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机</td><td>默认</td></tr><tr><td>HotSpot (Open JDK版)</td><td>Oracle</td><td>所有版本</td><td>中(16.1k)</td><td>同上开源，Open JDK默认虚拟机</td><td>默认对JDK有二次开发需求</td></tr><tr><td>GraalVM</td><td>Oracle</td><td>11, 17,19企业版支持8</td><td>高（18.7k）</td><td>多语言支持高性能、JIT、AOT支持</td><td>微服务、云原生架构需要多语言混合编程</td></tr><tr><td>Dragonwell JDK龙井</td><td>Alibaba</td><td>标准版 8,11,17扩展版11,17</td><td>低(3.9k)</td><td>基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持</td><td>电商、物流、金融领域对性能要求比较高</td></tr><tr><td>Eclipse OpenJ9 (原 IBM J9)</td><td>IBM</td><td>8,11,17,19,20</td><td>低(3.1k)</td><td>高性能、可扩展JIT、AOT特性支持</td><td>微服务、云原生架构</td></tr></tbody></table><h2 id="HotSpot的发展历程"><a href="#HotSpot的发展历程" class="headerlink" title="HotSpot的发展历程"></a>HotSpot的发展历程</h2><h5 id="初出茅庐-1999年4月"><a href="#初出茅庐-1999年4月" class="headerlink" title="初出茅庐 - 1999年4月"></a>初出茅庐 - 1999年4月</h5><p>源自1997年收购的SmallTalk语言的虚拟机，HotSpot虚拟机初次在JDK中使用。在JDK1.2中作为附加功能存在，</p><p>JDK1.3之后作为默认的虚拟机。</p><h5 id="野蛮生长-2006年12月"><a href="#野蛮生长-2006年12月" class="headerlink" title="野蛮生长 - 2006年12月"></a>野蛮生长 - 2006年12月</h5><p>JDK 6发布，并在虚拟机层面做了大量的优化，这些优化对后续虚拟机的发展产生了深远的影响。</p><h5 id="稳步前进-2009-2013"><a href="#稳步前进-2009-2013" class="headerlink" title="稳步前进 - 2009-2013"></a>稳步前进 - 2009-2013</h5><p>JDK7中首次推出了G1垃圾收集器。收购了Sun公司之后，吸纳了JRockIt虚拟机的一些设计思想，JDK8中引入了JMC等工具，去除了永久代。</p><h5 id="百家争鸣-2018-2019"><a href="#百家争鸣-2018-2019" class="headerlink" title="百家争鸣 - 2018-2019"></a>百家争鸣 - 2018-2019</h5><p>JDK11优化了G1垃圾收集器的性能,同时推出了ZGC新一代的垃圾回收器，JDK12推出Shenan-doah垃圾回收器。</p><h5 id="拥抱云原生-2019-至今"><a href="#拥抱云原生-2019-至今" class="headerlink" title="拥抱云原生 - 2019-至今"></a>拥抱云原生 - 2019-至今</h5><p>以Hotspot为基础的GraalVM虚拟机诞生，不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构。</p><h2 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h2><ul><li>类加载器ClassLoader 加载class字节码文件中的内容到内存中</li><li>运行时数据区域（jvm管理的内存）负责管理jvm使用到的内存，创建对象你和销毁对象</li><li>执行引擎（即时编译器，解释器，垃圾回收器等） 将字节码文件中的指令解释称机械码，同时使用即时编译器优化性能</li><li>本地接口 调用本地已经变异的方法，比如虚拟机中提供的c&#x2F;c++的方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> sleep（）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger</title>
      <link href="/KendricW.github.io/2024/03/17/swagger/"/>
      <url>/KendricW.github.io/2024/03/17/swagger/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<a href="https://swagger.io/">https://swagger.io/</a>)。 它的主要作用是：</p><ol><li><p>使得前后端分离开发更加方便，有利于团队协作</p></li><li><p>接口的文档在线自动生成，降低后端开发人员编写接口文档的负担</p></li><li><p>功能测试 </p><p>Spring已经将Swagger纳入自身的标准，建立了Spring-swagger项目，现在叫Springfox。通过在项目中引入Springfox ，即可非常简单快捷的使用Swagger。</p></li></ol><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p><p>目前，一般都使用knife4j框架。</p><h2 id="使用步骤（版本1）"><a href="#使用步骤（版本1）" class="headerlink" title="使用步骤（版本1）"></a>使用步骤（版本1）</h2><ol><li><h3 id="导入-knife4j-的maven坐标"><a href="#导入-knife4j-的maven坐标" class="headerlink" title="导入 knife4j 的maven坐标"></a>导入 knife4j 的maven坐标</h3><p>在pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3 id="在配置类中加入-knife4j-相关配置"><a href="#在配置类中加入-knife4j-相关配置" class="headerlink" title="在配置类中加入 knife4j 相关配置"></a>在配置类中加入 knife4j 相关配置</h3><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过knife4j生成接口文档</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Docket</span> <span class="variable">docket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.sky.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="设置静态资源映射，否则接口文档页面无法访问"><a href="#设置静态资源映射，否则接口文档页面无法访问" class="headerlink" title="设置静态资源映射，否则接口文档页面无法访问"></a>设置静态资源映射，否则接口文档页面无法访问</h3><p>WebMvcConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置静态资源映射</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/doc.html&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>接口文档访问路径为 <a href="http://ip:port/doc.html">http://ip:port/doc.html</a> —&gt; <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></p><h2 id="使用步骤（版本2）"><a href="#使用步骤（版本2）" class="headerlink" title="使用步骤（版本2）"></a>使用步骤（版本2）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.usercenter.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;, &quot;test&quot;&#125;)</span>   <span class="comment">//版本控制访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;defaultApi2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">defaultApi2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// 这里一定要标注你控制器的位置</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * api 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;标题&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;描述&quot;</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;邮箱&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;作者名&quot;</span>,<span class="string">&quot;网站&quot;</span>,<span class="string">&quot;邮箱&quot;</span>))</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>通过注解可以控制生成的接口文档，使接口文档拥有更好的可读性，常用注解如下：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@Api</td><td>用在类上，例如Controller，表示对类的说明</td></tr><tr><td>@ApiModel</td><td>用在类上，例如entity、DTO、VO</td></tr><tr><td>@ApiModelProperty</td><td>用在属性上，描述属性信息</td></tr><tr><td>@ApiOperation</td><td>用在方法上，例如Controller的方法，说明方法的用途、作用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口测试 </tag>
            
            <tag> kni4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>签到及连续签到统计</title>
      <link href="/KendricW.github.io/2024/03/16/%E7%AD%BE%E5%88%B0%E5%8F%8A%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1/"/>
      <url>/KendricW.github.io/2024/03/16/%E7%AD%BE%E5%88%B0%E5%8F%8A%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><h4 id="用户签到-BitMap功能演示"><a href="#用户签到-BitMap功能演示" class="headerlink" title="用户签到-BitMap功能演示"></a>用户签到-BitMap功能演示</h4><p>我们针对签到功能完全可以通过mysql来完成</p><p>用户一次签到，就是一条记录，假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条</p><p>每签到一次需要使用（8 + 8 + 1 + 1 + 3 + 1）共22 字节的内存，一个月则最多需要600多字节</p><p>我们如何能够简化一点呢？其实可以考虑小时候一个挺常见的方案，就是小时候，咱们准备一张小小的卡片，你只要签到就打上一个勾，我最后判断你是否签到，其实只需要到小卡片上看一看就知道了</p><p>我们可以采用类似这样的方案来实现我们的签到需求。</p><p>我们按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><p>把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态，这种思路就称为位图（BitMap）。这样我们就用极小的空间，来实现了大量数据的表示</p><p>Redis中是利用string类型数据结构实现BitMap，因此最大上限是512M，转换为bit则是 2^32个bit位。</p><p><em><strong>BitMap的操作命令有：</strong></em></p><ul><li><em><strong>SETBIT：向指定位置（offset）存入一个0或1</strong></em></li><li><em><strong>GETBIT ：获取指定位置（offset）的bit值</strong></em></li><li><em><strong>BITCOUNT ：统计BitMap中值为1的bit位的数量</strong></em></li><li><em><strong>BITFIELD ：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</strong></em></li><li><em><strong>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</strong></em></li><li><em><strong>BITOP ：将多个BitMap的结果做位运算（与 、或、异或）</strong></em></li><li><em><strong>BITPOS ：查找bit数组中指定范围内第一个0或1出现的位置</strong></em></li><li></li></ul><h4 id="用户签到-实现签到功能"><a href="#用户签到-实现签到功能" class="headerlink" title="用户签到-实现签到功能"></a>用户签到-实现签到功能</h4><p>需求：实现签到接口，将当前用户当天签到信息保存到Redis中</p><p>思路：我们可以把年和月作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><p>我们通过接口文档发现，此接口并没有传递任何的参数，没有参数怎么确实是哪一天签到呢？这个很容易，可以通过后台代码直接获取即可，然后到对应的地址上去修改bitMap。</p><p><strong>代码</strong></p><p>UserController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userService.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sign</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.写入Redis SETBIT key offset 1</span></span><br><span class="line">    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户签到-签到统计"><a href="#用户签到-签到统计" class="headerlink" title="用户签到-签到统计"></a>用户签到-签到统计</h4><p><strong>问题1：</strong>什么叫做连续签到天数？<br>从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数，就是连续签到天数。</p><p>Java逻辑代码：获得当前这个月的最后一次签到数据，定义一个计数器，然后不停的向前统计，直到获得第一个非0的数字即可，每得到一个非0的数字计数器+1，直到遍历完所有的数据，就可以获得当前月的签到总天数了</p><p><strong>问题2：</strong>如何得到本月到今天为止的所有签到数据？</p><p>  BITFIELD key GET u[dayOfMonth] 0</p><p>假设今天是10号，那么我们就可以从当前月的第一天开始，获得到当前这一天的位数，是10号，那么就是10位，去拿这段时间的数据，就能拿到所有的数据了，那么这10天里边签到了多少次呢？统计有多少个1即可。</p><p><strong>问题3：如何从后向前遍历每个bit位？</strong></p><p>注意：bitMap返回的数据是10进制，哪假如说返回一个数字8，那么我哪儿知道到底哪些是0，哪些是1呢？我们只需要让得到的10进制数字和1做与运算就可以了，因为1只有遇见1 才是1，其他数字都是0 ，我们把签到结果和1进行与操作，每与一次，就把签到结果向右移动一位，依次内推，我们就能完成逐个遍历的效果了。</p><p>需求：实现下面接口，统计当前用户截止当前时间在本月的连续签到天数</p><p>有用户有时间我们就可以组织出对应的key，此时就能找到这个用户截止这天的所有签到记录，再根据这套算法，就能统计出来他连续签到的次数了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>UserController</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sign/count&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.signCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">signCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前登录用户</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// 2.获取日期</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 3.拼接key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keySuffix</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;:yyyyMM&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class="line">    <span class="comment">// 4.获取今天是本月的第几天</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">    <span class="comment">// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class="line">    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands.create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="number">0</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> || result.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 没有任何签到结果</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">num</span> <span class="operator">=</span> result.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="literal">null</span> || num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.循环遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果为0，说明未签到，结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为0，说明已签到，计数器+1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 签到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量删除</title>
      <link href="/KendricW.github.io/2024/03/16/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4xmlsql/"/>
      <url>/KendricW.github.io/2024/03/16/%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4xmlsql/</url>
      
        <content type="html"><![CDATA[<h3 id="Mapper层"><a href="#Mapper层" class="headerlink" title="Mapper层"></a>Mapper层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SetmealDishMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据菜品id查询对应的套餐id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dishIds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)</span></span><br><span class="line">    List&lt;Long&gt; <span class="title function_">getSetmealIdsByDishIds</span><span class="params">(List&lt;Long&gt; dishIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sky.mapper.SetmealDishMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSetmealIdsByDishIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">        select setmeal_id from setmeal_dish where dish_id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;dishIds&quot;</span> <span class="attr">item</span>=<span class="string">&quot;dishId&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;dishId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>collection</code>: Mapper层传入的集合参数</p><p><code>item</code>: 当前遍历集合的元素</p><p><code>separator</code>: 每个元素之间的分隔符</p><p><code>open=&quot;(&quot;</code> : 左侧拼接(</p><p><code>close=&quot;)&quot;</code>: 右侧拼接)</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批量删除 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/KendricW.github.io/2024/03/16/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/KendricW.github.io/2024/03/16/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h2><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p>省略解压的部分<br>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>默认的安装路径是在 <code>/usr/local/bin</code>目录<br>如果没有出错，应该就安装成功了。<br>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h2 id="Redis桌面客户端"><a href="#Redis桌面客户端" class="headerlink" title="Redis桌面客户端"></a>Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台</p><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">help</span> keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h2 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>进入到sky-server模块</p><p><strong>1). 导入Spring Data Redis的maven坐标(已完成)</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置Redis数据源</strong></p><p>在application-dev.yml中添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sky:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p><p>在application.yml中添加读取application-dev.yml中的相关Redis配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;sky.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;sky.redis.port&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;sky.redis.password&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;sky.redis.database&#125;</span></span><br></pre></td></tr></table></figure><p><strong>3). 编写配置类，创建RedisTemplate对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始创建redis模板对象...&quot;</span>);</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        <span class="comment">//设置redis的连接工厂对象</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//设置redis key的序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为</p><p>JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为</p><p>StringRedisSerializer序列化器。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>登录与校验的思路</title>
      <link href="/KendricW.github.io/2024/03/13/%E7%99%BB%E5%BD%95%E4%B8%8E%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/KendricW.github.io/2024/03/13/%E7%99%BB%E5%BD%95%E4%B8%8E%E6%A0%A1%E9%AA%8C%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="登录校验思路"><a href="#登录校验思路" class="headerlink" title="登录校验思路"></a>登录校验思路</h1><p><code>DTO</code>：DTO是一种设计模式，它主要用来封装需要在网络间传输的数据或者在应用程序的不同层级间进行传递的对象。DTO通常包含了服务层操作所需的全部或部分数据</p><p><code>VO</code>：用于封装用户界面展示所需的数据，以及接收用户输入的数据。</p><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;员工登录&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;EmployeeLoginVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;员工登录：&#123;&#125;&quot;</span>, employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.login(employeeLoginDTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//登录成功后，生成jwt令牌</span></span><br><span class="line">    Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    claims.put(JwtClaimsConstant.EMP_ID, employee.getId());</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createJWT(</span><br><span class="line">            jwtProperties.getAdminSecretKey(),</span><br><span class="line">            jwtProperties.getAdminTtl(),</span><br><span class="line">            claims);</span><br><span class="line"></span><br><span class="line">    <span class="type">EmployeeLoginVO</span> <span class="variable">employeeLoginVO</span> <span class="operator">=</span> EmployeeLoginVO.builder()</span><br><span class="line">            .id(employee.getId())</span><br><span class="line">            .userName(employee.getUsername())</span><br><span class="line">            .name(employee.getName())</span><br><span class="line">            .token(token)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(employeeLoginVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JwtUtil工具类"><a href="#JwtUtil工具类" class="headerlink" title="JwtUtil工具类"></a>JwtUtil工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jwt</span></span><br><span class="line"><span class="comment">     * 使用Hs256算法, 私匙使用固定秘钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis jwt过期时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims    设置的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String secretKey, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定签名的时候使用的签名算法，也就是header那部分</span></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成JWT的时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> System.currentTimeMillis() + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置jwt的body</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的</span></span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                <span class="comment">// 设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置过期时间</span></span><br><span class="line">                .setExpiration(exp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Token解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造, 如果对接多个客户端建议改造成多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token     加密后的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String secretKey, String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到DefaultJwtParser</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                <span class="comment">// 设置签名的秘钥</span></span><br><span class="line">                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">                <span class="comment">// 设置需要解析的jwt</span></span><br><span class="line">                .parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 员工登录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employeeLoginDTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">login</span><span class="params">(EmployeeLoginDTO employeeLoginDTO)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> employeeLoginDTO.getUsername();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> employeeLoginDTO.getPassword();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、根据用户名查询数据库中的数据</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.getByUsername(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、处理各种异常情况（用户名不存在、密码不对、账号被锁定）</span></span><br><span class="line">        <span class="keyword">if</span> (employee == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//账号不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountNotFoundException</span>(MessageConstant.ACCOUNT_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//密码比对</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        password = DigestUtils.md5DigestAsHex(password.getBytes());</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(employee.getPassword())) &#123;</span><br><span class="line">            <span class="comment">//密码错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PasswordErrorException</span>(MessageConstant.PASSWORD_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (employee.getStatus() == StatusConstant.DISABLE) &#123;</span><br><span class="line">            <span class="comment">//账号被锁定</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountLockedException</span>(MessageConstant.ACCOUNT_LOCKED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、返回实体对象</span></span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>安全起见，密码不是明文传输，使用<code>DigestUtils.md5DigestAsHex（）</code>进行MD5加密处理</p><h2 id="JwtTokenAdminInterceptor拦截器"><a href="#JwtTokenAdminInterceptor拦截器" class="headerlink" title="JwtTokenAdminInterceptor拦截器"></a>JwtTokenAdminInterceptor拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sky.constant.JwtClaimsConstant;</span><br><span class="line"><span class="keyword">import</span> com.sky.context.BaseContext;</span><br><span class="line"><span class="keyword">import</span> com.sky.properties.JwtProperties;</span><br><span class="line"><span class="keyword">import</span> com.sky.utils.JwtUtil;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jwt令牌校验的拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenAdminInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验jwt</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//判断当前拦截到的是Controller的方法还是其他资源</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="comment">//当前拦截到的不是动态方法，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、从请求头中获取令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(jwtProperties.getAdminTokenName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、校验令牌</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;jwt校验:&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">empId</span> <span class="operator">=</span> Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());</span><br><span class="line">            log.info(<span class="string">&quot;当前员工id：&quot;</span>, empId);</span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line">            <span class="comment">//3、通过，放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">//4、不通过，响应401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求头中获得token并解析，判断是否有效</p><ul><li>无效，不放行</li><li>有效，拿到token中存入的员工id并存放到ThreadLocal当中</li></ul><h2 id="ThreadLocal封装类"><a href="#ThreadLocal封装类" class="headerlink" title="ThreadLocal封装类"></a>ThreadLocal封装类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每一个线程都有一个独立的存储空间。此处存放的是当前用户的id，以便后续获取当前登录用户信息。</p>]]></content>
      
      
      <categories>
          
          <category> 开发思路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 登录 </tag>
            
            <tag> 校验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/KendricW.github.io/2024/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/KendricW.github.io/2024/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="根据目的分类"><a href="#根据目的分类" class="headerlink" title="根据目的分类"></a>根据目的分类</h2><ul><li>创建型<ul><li>创建对象</li></ul></li><li>结构型<ul><li>处理类或者对象</li></ul></li><li>行为型<ul><li>描述类或者对象如何交互和怎样分配职责</li></ul></li></ul><h2 id="根据范围分类"><a href="#根据范围分类" class="headerlink" title="根据范围分类"></a>根据范围分类</h2><ul><li>类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是一种静态关系</li><li>对象模式处理对象间的关系，这些关系在运行时变化，更具动态性</li></ul><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>定义</strong>：软件实体应对扩展开放，对修改关闭</p><p><strong>实现</strong>：抽象化是开闭原则的关键，提供相对稳定的抽象层和灵活的具体层</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p><strong>定义</strong>：所有引用基类的地方必须能透明地使用其子类的对象</p><p><strong>实现</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。</p><h3 id="依赖倒转-置-原则定义"><a href="#依赖倒转-置-原则定义" class="headerlink" title="依赖倒转(置)原则定义"></a>依赖倒转(置)原则定义</h3><p>高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象</p><p>满足依赖倒置原则：</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小</p><p>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>客户端不应该依赖那些它不需要的接口</p><p>接口隔离原则的实现方法：</p><ol><li>接口尽量小，但是要有限度。</li><li>只提供调用者需要的方法,屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。</li><li>提高内聚，减少对外交互</li></ol><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则又称为最少知识原则</p><p>每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则又称为组合&#x2F;聚合复用原则</p><p>优先使用对象组合，而不是继承来达到复用的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字母异位词分组</title>
      <link href="/KendricW.github.io/2024/03/12/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
      <url>/KendricW.github.io/2024/03/12/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p>[toc]</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><h2 id="题解1（质数）"><a href="#题解1（质数）" class="headerlink" title="题解1（质数）"></a><strong>题解1（质数）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, Integer&gt; MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">        put(<span class="string">&#x27;c&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// ... 省略其他字符和对应的数值</span></span><br><span class="line">        put(<span class="string">&#x27;z&#x27;</span>, <span class="number">101</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; resMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                hash *= MAP.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!resMap.containsKey(hash)) &#123;</span><br><span class="line">                resMap.put(hash, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            resMap.get(hash).add(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resMap.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题解2（stream流）"><a href="#题解2（stream流）" class="headerlink" title="题解2（stream流）"></a><strong>题解2（stream流）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将给定字符串数组按照其中每个字符串的字母异位词进行分组，并返回一个包含这些分组的列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 输入的字符串数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个列表，其中每个元素是属于同一字母异位词组的字符串列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">                Arrays.stream(strs)</span><br><span class="line">                        <span class="comment">// 使用sortedCharsToString方法将每个字符串转换为它的排序后字符表示，以此作为分组键</span></span><br><span class="line">                        .collect(Collectors.groupingBy(<span class="built_in">this</span>::sortedCharsToString))</span><br><span class="line">                        <span class="comment">// 取得所有分组值（即每个组内的字符串集合）</span></span><br><span class="line">                        .values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有辅助方法，接收一个字符串参数并返回其内部字符经过排序后的字符串形式。</span></span><br><span class="line"><span class="comment">     * 这个方法用于识别和区分字母异位词。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 输入的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串s中所有字符按字典序排序后的新字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">sortedCharsToString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符流，排序后构建新的字符串</span></span><br><span class="line">        <span class="keyword">return</span> s.chars()</span><br><span class="line">                .sorted()</span><br><span class="line">                .collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::appendCodePoint, StringBuilder::append)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解3（官方）"><a href="#题解3（官方）" class="headerlink" title="题解3（官方）"></a><strong>题解3（官方）</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个字符串数组，将其中的字母异位词分组并返回结果列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strs 字符串数组，包含多个可能为字母异位词的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 一个List&lt;List&lt;String&gt;&gt;类型的对象，每个内部列表代表一组字母异位词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap来存储字母异位词分组，键是排序后的字符组成的字符串，值是一个字符串列表</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输入的字符串数组</span></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="comment">// 将当前字符串转换为字符数组</span></span><br><span class="line">            <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对字符数组进行排序，使得所有相同字母异位词在排序后得到相同的字符序列</span></span><br><span class="line">            Arrays.sort(array);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将排序后的字符数组转换回字符串作为哈希表的键</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取或初始化与当前键关联的字符串列表（若不存在则创建一个新的ArrayList）</span></span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向对应的列表中添加原始的字符串</span></span><br><span class="line">            list.add(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新映射表，将排序后字符串对应的列表存入键值对中</span></span><br><span class="line">            map.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将映射表中的所有值（即每组字母异位词的列表）转换为一个新的ArrayList，并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零</title>
      <link href="/KendricW.github.io/2024/03/12/%E7%AE%97%E6%B3%95-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/KendricW.github.io/2024/03/12/%E7%AE%97%E6%B3%95-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="移动零（简单）"><a href="#移动零（简单）" class="headerlink" title="移动零（简单）"></a>移动零（简单）</h1><p>[toc]</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 移动零 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//如果数组是空的直接返回，不浪费时间</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录非零的数目</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一次遍历的时候，只要是非0的统统都赋给nums[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将后面的数补0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://big-event-wzx.oss-cn-beijing.aliyuncs.com/image-20240312002556724.png" alt="成果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/KendricW.github.io/2024/03/10/hello-world/"/>
      <url>/KendricW.github.io/2024/03/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
